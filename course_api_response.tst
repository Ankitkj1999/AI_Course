curl 'http://localhost:5010/api/courses?userId=68d593ab8f080eae321d2b31&page=1&limit=9' \
  -H 'sec-ch-ua-platform: "macOS"' \
  -H 'Referer: http://localhost:8080/' \
  -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36' \
  -H 'Accept: application/json, text/plain, */*' \
  -H 'sec-ch-ua: "Chromium";v="142", "Google Chrome";v="142", "Not_A Brand";v="99"' \
  -H 'DNT: 1' \
  -H 'sec-ch-ua-mobile: ?0'

  Response

  {
    "success": true,
    "courses": [
        {
            "forkedFrom": {
                "contentId": null,
                "originalOwnerId": null,
                "originalOwnerName": null,
                "forkedAt": null
            },
            "_id": "69105b056a6b3cdf09064f03",
            "user": "68d593ab8f080eae321d2b31",
            "content": "{\"fundamentals of dbms\":[{\"title\":\"Introduction to DBMS\",\"subtopics\":[{\"title\":\"What is a DBMS?\",\"theory\":\"A Database Management System (DBMS) is a software system designed to define, create, manipulate, and manage data in a database. It acts as an interface between the database itself and its end-users or application programs, ensuring that data is organized, accessible, and secure.\\n\\nTo understand \\\"What is a DBMS?\\\", let's break down its core aspects:\\n\\n1.  **What is a Database?**\\n    Before discussing a DBMS, it's essential to know what a database is. A database is an organized collection of structured information, or data, typically stored electronically in a computer system. It's designed for efficient storage, retrieval, and management of data. For example, a university database might store information about students (names, IDs, courses), faculty (names, departments), and courses (titles, credits).\\n\\n2.  **The Need for a DBMS (Why not just files?)**\\n    In the early days of computing, data was stored in simple file systems. However, this approach presented several problems:\\n    *   **Data Redundancy and Inconsistency:** The same data might be stored in multiple files, leading to wasted space and different versions of the same data (e.g., a student's address updated in one file but not another).\\n    *   **Difficulty in Accessing Data:** Retrieving specific information often required writing complex programs for each query.\\n    *   **Data Isolation:** Data was scattered in various files, potentially in different formats, making it hard to combine information.\\n    *   **Integrity Problems:** Enforcing rules (e.g., a student's age must be positive) was difficult and required application-level coding.\\n    *   **Atomicity Problems:** If a transaction (like transferring money) failed midway, the database could be left in an inconsistent state.\\n    *   **Concurrent Access Anomalies:** Multiple users accessing and modifying data simultaneously could lead to errors or lost updates.\\n    *   **Security Problems:** Controlling who could access what data was complex.\\n\\n    A DBMS addresses these issues by providing a centralized and systematic way to manage data.\\n\\n3.  **Key Functions and Characteristics of a DBMS:**\\n    A DBMS offers a robust set of features to overcome the limitations of file systems:\\n\\n    *   **Data Definition:** It provides a Data Definition Language (DDL) to define the database schema, which includes creating tables, specifying data types for columns, defining constraints (e.g., primary keys, foreign keys), and setting up relationships between tables.\\n        *   **Example:** `CREATE TABLE Students (StudentID INT PRIMARY KEY, Name VARCHAR(50), Major VARCHAR(50));`\\n    *   **Data Manipulation:** It provides a Data Manipulation Language (DML) to insert, update, delete, and retrieve data from the database.\\n        *   **Example (Insert):** `INSERT INTO Students (StudentID, Name, Major) VALUES (101, 'Alice', 'Computer Science');`\\n        *   **Example (Retrieve):** `SELECT Name, Major FROM Students WHERE StudentID = 101;`\\n    *   **Data Security:** A DBMS implements security measures to protect data from unauthorized access. It handles user authentication (verifying identity) and authorization (what actions a user can perform on specific data).\\n        *   **Example:** Only a university registrar might have permission to update student grades, while a student can only view their own grades.\\n    *   **Data Integrity:** It enforces rules and constraints to ensure the accuracy and consistency of data. These can include domain constraints (e.g., age must be an integer), referential integrity (ensuring relationships between tables are valid, like a course ID in a student's record must exist in the courses table), and entity integrity (primary key must be unique and not null).\\n        *   **Example:** If a course is deleted from the `Courses` table, the DBMS might prevent this if there are students still enrolled in that course (due to a foreign key constraint).\\n    *   **Concurrency Control:** A DBMS manages simultaneous access to the database by multiple users or applications, ensuring that their operations do not interfere with each other and data consistency is maintained.\\n        *   **Example:** If two instructors try to update the same student's grade at the exact same time, the DBMS ensures that one update is completed before the other, preventing data corruption.\\n    *   **Backup and Recovery:** It provides utilities to create backups of the database and restore it to a consistent state in case of hardware failure, software error, or other disasters.\\n        *   **Example:** If the server crashes, the DBMS can restore the database to its last consistent state using transaction logs and backups.\\n    *   **Data Independence:** It separates the logical view of the data (how users and applications perceive it) from the physical storage details (how data is actually stored on disk). This means changes in physical storage don't necessarily require changes in application programs.\\n    *   **Multiple User Interfaces:** It offers various ways for users to interact, including graphical user interfaces (GUIs), command-line interfaces (like SQL clients), and application programming interfaces (APIs) for programmatic access.\\n\\n4.  **Examples of DBMS:**\\n    There are many popular DBMS products, each with its strengths and typical use cases:\\n    *   **MySQL:** A widely used open-source relational DBMS, popular for web applications.\\n    *   **PostgreSQL:** Another powerful open-source relational DBMS, known for its advanced features and compliance with standards.\\n    *   **Oracle Database:** A highly scalable and robust commercial relational DBMS, often used in large enterprise environments.\\n    *   **Microsoft SQL Server:** A commercial relational DBMS from Microsoft, popular in Windows-based environments.\\n    *   **IBM DB2:** A powerful relational DBMS from IBM, often used in large enterprise and mainframe systems.\\n    *   **SQLite:** A lightweight, embedded relational DBMS, commonly used in mobile applications and small-scale projects.\\n    *   **MongoDB:** A popular NoSQL (non-relational) DBMS that stores data in document-like structures, suitable for handling large volumes of unstructured data.\\n\\nIn essence, a DBMS acts as a sophisticated manager for your data, providing the tools and rules to store, organize, protect, and retrieve information efficiently and reliably. It transforms raw data into a structured, usable, and valuable asset.\",\"youtube\":\"\",\"image\":\"https://trainings.internshala.com/blog/wp-content/uploads/2024/02/Database-Management-System-1.jpg\",\"done\":false},{\"title\":\"Advantages and Disadvantages of DBMS\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Data Abstraction and Data Independence\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Database Users and Administrators\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Database Architecture (3-tier, 2-tier)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Relational Model\",\"subtopics\":[{\"title\":\"Relational Model Concepts (Tuples, Attributes, Domains)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Keys (Primary, Foreign, Candidate, Super)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Relational Algebra Operations\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Integrity Constraints (Entity, Referential, Domain)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"SQL Fundamentals\",\"subtopics\":[{\"title\":\"SQL Data Types\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"DDL Commands (CREATE, ALTER, DROP)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"DML Commands (INSERT, SELECT, UPDATE, DELETE)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"DCL Commands (GRANT, REVOKE)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"TCL Commands (COMMIT, ROLLBACK, SAVEPOINT)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Basic SELECT Queries (WHERE, ORDER BY, GROUP BY, HAVING)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"JOIN Operations (INNER, LEFT, RIGHT, FULL)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Database Design\",\"subtopics\":[{\"title\":\"ER Model Concepts (Entities, Attributes, Relationships)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Cardinality and Participation Constraints\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Mapping ER Model to Relational Schema\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Normalization (1NF, 2NF, 3NF, BCNF)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Denormalization\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]}]}",
            "type": "Text & Image Course",
            "mainTopic": "fundamentals of dbms",
            "slug": "fundamentals-of-dbms",
            "photo": null,
            "completed": false,
            "isPublic": false,
            "forkCount": 0,
            "ownerName": "",
            "date": "2025-11-09T09:12:37.261Z",
            "end": "2025-11-09T09:12:37.261Z"
        },
        {
            "forkedFrom": {
                "contentId": null,
                "originalOwnerId": null,
                "originalOwnerName": null,
                "forkedAt": null
            },
            "isPublic": false,
            "forkCount": 0,
            "ownerName": "",
            "_id": "690da42d9b486990d684946f",
            "user": "68d593ab8f080eae321d2b31",
            "content": "{\"generative ai\":[{\"title\":\"Introduction to Generative AI\",\"subtopics\":[{\"title\":\"Definition and Core Concepts\",\"theory\":\"Generative AI refers to artificial intelligence systems designed to create new content, such as text, images, music, or data, that resembles the training data it has learned from. Unlike discriminative models that classify or predict, generative models focus on generating outputs by learning patterns, structures, or distributions from existing data. The core concept is that these systems can produce original outputs by simulating the statistical properties of the input data.\\n\\nKey core concepts include:  \\n1. **Data Generation**: The ability to produce new, realistic data (e.g., generating a photo of a person who doesn’t exist).  \\n2. **Pattern Learning**: Analyzing large datasets to identify underlying patterns, relationships, or styles (e.g., learning how sentences are structured to write coherent text).  \\n3. **Latent Space Representation**: Encoding data into a compressed, abstract space where the model can navigate to generate new variations (e.g., adjusting parameters in a latent space to create different images).  \\n4. **Probability Distributions**: Using learned probabilities to sample and create new instances (e.g., predicting the likelihood of certain words in a sentence to generate text).  \\n\\nExamples:  \\n- A generative AI model trained on images of cats can generate a new, realistic cat image never seen before.  \\n- A text-generating AI like GPT can write a story or email by predicting likely word sequences based on its training data.  \\n- A music-generating AI can compose a melody by learning patterns from a dataset of songs.\\n\",\"youtube\":\"\",\"image\":\"https://www.tredence.com/assets/decoder/GenAI-Model.png\",\"done\":false},{\"title\":\"Historical Development and Milestones\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Model Architectures\",\"subtopics\":[{\"title\":\"Generative Adversarial Networks (GANs)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Transformer-Based Models in Generation\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Applications in Creative Fields\",\"subtopics\":[{\"title\":\"Text Generation and Natural Language Processing\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"AI in Music and Audio Generation\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Ethical and Societal Impact\",\"subtopics\":[{\"title\":\"Bias and Fairness in Generative Systems\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Copyright and Originality Concerns\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]}]}",
            "type": "Text & Image Course",
            "mainTopic": "generative ai",
            "slug": "generative-ai",
            "photo": "https://images.unsplash.com/photo-1674027444485-cec3da58eef4?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w1NDM1MTN8MHwxfHNlYXJjaHwxfHxnZW5lcmF0aXZlJTIwYWl8ZW58MHwwfHx8MTc2MjUwMTY3N3ww&ixlib=rb-4.1.0&q=80&w=1080",
            "completed": false,
            "date": "2025-11-07T07:47:57.662Z",
            "end": "2025-11-07T07:47:57.662Z"
        },
        {
            "forkedFrom": {
                "contentId": null,
                "originalOwnerId": null,
                "originalOwnerName": null,
                "forkedAt": null
            },
            "isPublic": false,
            "forkCount": 0,
            "ownerName": "",
            "_id": "6907a43220ceab4271de92de",
            "user": "68d593ab8f080eae321d2b31",
            "content": "{\"theory of automata\":[{\"title\":\"Formal Languages and Grammars\",\"subtopics\":[{\"title\":\"Chomsky Hierarchy\",\"theory\":\"The **Chomsky Hierarchy** is a fundamental classification system for formal languages and the grammar rules that generate them, also corresponding to the types of automata that can recognize them. It's a nested structure, meaning each level includes all languages from the levels below it, plus additional, more powerful languages.\\n\\nHere's a breakdown of its four main levels (Type 0 to Type 3):\\n\\n1.  **Type 0: Unrestricted Grammar / Turing Machine (Recursively Enumerable Languages)**\\n    *   **Grammar Rules:** The most general form. Productions look like `α -> β`, where `α` and `β` are any strings of non-terminals and terminals (`α` *cannot* be the empty string). Any non-terminal can replace any string of symbols by any other string.\\n    *   **Automata:** Turing Machines (TMs).\\n    *   **Languages:** Recursively Enumerable (RE) languages. These are *exactly* the languages that *some* Turing Machine will halt and accept (or loop forever on strings not in the language). This is the most powerful class.\\n    *   **Computational Capability:** Equivalent to what any computer algorithm can do.\\n    *   **Example Language:** `L = { a^n b^n c^n | n >= 1 }`. *(Requires context-sensitive grammar like `S -> abc | aAbcc`, `A -> aAb | bc`)*\\n    *   **Example Problem:** The **Halting Problem** (undecidable).\\n\\n2.  **Type 1: Context-Sensitive Grammar / Linear Bounded Automaton (Context-Sensitive Languages)**\\n    *   **Grammar Rules:** Productions look like `α -> β` with the constraint that `|α| <= |β|` (length of left-hand side is less than or equal to length of right-hand side). A notable exception allows `S -> ε` only if `S` doesn't appear on the right side of any production (to handle empty string).\\n    *   **Automata:** Linear Bounded Automata (LBA). Non-deterministic TMs whose tape is bounded by a linear function of the input size.\\n    *   **Languages:** Context-Sensitive (CS) languages. These are languages that can be decided by an LBA.\\n    *   **Computational Capability:** More powerful than context-free but less than unrestricted. LBAs run in exponential space complexity in the worst case.\\n    *   **Example Language:** `L = { a^n b^n c^n | n >= 0 }`. *(Contains the empty string due to the `S -> ε` rule in some grammars)*. Also, `{ ww | w ∈ {a,b}* }` (strings that are concatenations of two identical substrings).\\n    *   **Example Problem:** Deciding if two context-sensitive grammars generate the same language.\\n\\n3.  **Type 2: Context-Free Grammar / Pushdown Automaton (Context-Free Languages)**\\n    *   **Grammar Rules:** Productions look like `A -> γ` (where `A` is a *single* non-terminal, and `γ` is any string of terminals/non-terminals, *including the empty string*). The key difference from Type 1 is that the left-hand side must be a single non-terminal (`A`), meaning replacements happen *independently of context*.\\n    *   **Automata:** Pushdown Automata (PDA). Finite State Machines augmented with a stack (LIFO memory structure). Non-deterministic.\\n    *   **Languages:** Context-Free (CF) languages. Languages recognized by some PDA. Includes all regular languages.\\n    *   **Computational Capability:** Powerful enough for nested structures (like balanced parentheses, matching identifiers and keywords in compilers).\\n    *   **Example Language:** `L = { a^n b^n | n >= 1 }`. *(Generated by `S -> aSb | ab`)*.\\n    *   **Example Language:** `L = { Balanced strings of parentheses }`. *(e.g., `()()`, `(()())`, `((()))`)*.\\n    *   **Decidability:** Membership is decidable (via CYK algorithm / Pushdown Automaton simulation). Language equivalence is undecidable.\\n\\n4.  **Type 3: Regular Grammar / Finite Automaton (Regular Languages)**\\n    *   **Grammar Rules:** Productions look like `A -> a` or `A -> aB` or `A -> ε` (where `A` and `B` are single non-terminals, and `a` is a single terminal). This enforces a very linear structure: each production either produces a single terminal or a terminal followed by one non-terminal. Can also be written as `A -> aB` or `A -> a` (right-linear), or `A -> Ba` (left-linear). These grammars generate exactly the regular languages.\\n    *   **Automata:** Deterministic Finite Automaton (DFA) or Non-Deterministic Finite Automaton (NFA). Basic finite-state machines with *no* memory beyond the current state.\\n    *   **Languages:** Regular languages. These languages are recognized by DFAs/NFAs. Includes simple patterns.\\n    *   **Computational Capability:** Very limited. Can check for simple patterns, prefixes, suffixes, or specific sequences. Can be checked efficiently (linear time O(n)).\\n    *   **Example Language:** `L = { all strings over {a, b} ending with \\\"ab\\\" }`. *(Recognized by a simple 3-state DFA)*.\\n    *   **Example Language:** `L = { strings over {a, b} with an even number of a's }`. *(Recognized by a simple 2-state DFA)*.\\n    *   **Decidability:** Membership, emptiness, equivalence, and inclusion are all decidable.\\n\\n**Summary of Relationships:**\\n\\n*   **Type 3 ⊂ Type 2 ⊂ Type 1 ⊂ Type 0** (Every language in a lower type is also in all higher types)\\n*   **Computational Power Increases:** Type 0 > Type 1 > Type 2 > Type 3\\n*   **Generality of Grammars Decreases:** Type 0 > Type 1 > Type 2 > Type 3\\n*   **Complexity of Recognition Increases:** Type 0 (Undecidable) > Type 1 (PSPACE) > Type 2 (Polynomial time O(n^3) - CYK) > Type 3 (Linear time O(n))\\n*   **Automata Complexity Increases:** TM > LBA > PDA > DFA/NFA\\n\\nThe Chomsky Hierarchy provides a crucial framework for understanding the landscape of formal languages, the expressive power of different grammar types, and the computational capabilities (and limitations) of the corresponding automata models.\",\"youtube\":\"\",\"image\":\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/20210407173848/12312.png\",\"done\":true},{\"title\":\"Regular Languages\",\"theory\":\"Okay, here's an explanation of Regular Languages in the context of Theory of Automata, strictly in English and without external resources or images:\\n\\n**Regular Languages: The Basics**\\n\\nRegular languages are a fundamental class of formal languages in computer science.  They are languages that can be recognized by a finite state machine (FSM), also known as a finite automaton (FA).  In simpler terms, a regular language is a set of strings that follow a specific pattern that a machine with limited memory (a finite number of states) can identify.\\n\\n**Key Characteristics**\\n\\n*   **Recognizable by Finite Automata:** The defining feature. If you can design a Finite Automaton (Deterministic or Non-Deterministic) that accepts all strings in a language and rejects all strings not in the language, that language is regular.\\n*   **Defined by Regular Expressions:** Regular languages can be described using regular expressions.  A regular expression is a pattern that specifies a set of strings.\\n*   **Limited Memory:**  Finite automata have a fixed, finite number of states. This means they cannot \\\"remember\\\" arbitrarily long sequences of characters. This limitation restricts the types of patterns they can recognize.\\n*   **Closure Properties:** Regular languages are \\\"closed\\\" under several operations. This means that if you perform certain operations on regular languages, the result will also be a regular language. Common closure properties include:\\n    *   **Union:** The union of two regular languages is regular.\\n    *   **Intersection:** The intersection of two regular languages is regular.\\n    *   **Complementation:** The complement of a regular language is regular.\\n    *   **Concatenation:** The concatenation of two regular languages is regular.\\n    *   **Kleene Star:** The Kleene star of a regular language is regular.\\n\\n**Examples**\\n\\n1.  **The language of all strings consisting of only 'a's:** This is a regular language. A simple FA can be built with two states: one initial state and one accepting state. The machine transitions to the accepting state on input 'a' and stays there.\\n    *   Strings in the language: \\\"\\\", \\\"a\\\", \\\"aa\\\", \\\"aaa\\\", \\\"aaaa\\\", ...\\n    *   Regular Expression: `a*`\\n\\n2.  **The language of all strings that start with 'a' and end with 'b':** This is also a regular language. An FA can keep track of whether the string has started with 'a' and then transition to an accepting state only if it sees a 'b' at the end.\\n    *   Strings in the language: \\\"ab\\\", \\\"aab\\\", \\\"abb\\\", \\\"aaab\\\", \\\"abab\\\", ...\\n    *   Regular Expression: `a.*b` (where `.` means any character and `*` means zero or more occurrences)\\n\\n3.  **The language of all strings containing the substring \\\"abc\\\":** This is regular. An FA can track whether it has seen 'a', then 'b', and then 'c' in sequence.\\n    *   Strings in the language: \\\"abc\\\", \\\"xabc\\\", \\\"abcx\\\", \\\"xabcx\\\", \\\"xyabc\\\", ...\\n    *   Regular Expression: `.*abc.*`\\n\\n4.  **The language of all strings of even length consisting of 'a's and 'b's:** This is regular. An FA can keep track of whether the length of the string seen so far is even or odd.\\n    *   Strings in the language: \\\"\\\", \\\"aa\\\", \\\"ab\\\", \\\"ba\\\", \\\"bb\\\", \\\"aaaa\\\", \\\"abab\\\", \\\"abba\\\", \\\"baab\\\", ...\\n    *   Regular Expression: `((a|b)(a|b))*`\\n\\n**Non-Regular Languages**\\n\\nLanguages that *cannot* be recognized by a finite automaton are called non-regular languages. This is often because they require the machine to \\\"remember\\\" an unbounded amount of information.\\n\\n**Example of a Non-Regular Language:**\\n\\n*   **The language of all strings of the form a<sup>n</sup>b<sup>n</sup> (equal number of 'a's followed by the same number of 'b's):** This is *not* a regular language. A finite automaton cannot remember how many 'a's it has seen to ensure it sees the same number of 'b's.  It would need to have a state for every possible count of 'a's, which is impossible with a finite number of states.\\n\\n**In Summary**\\n\\nRegular languages are a well-defined class of languages recognizable by finite automata and describable by regular expressions. Their key feature is the limited memory requirement for recognition. If a language requires unbounded memory to recognize, it's likely not regular.\\n\",\"youtube\":\"\",\"image\":\"https://i.ytimg.com/vi/WrzaPNj9OZ4/maxresdefault.jpg\",\"done\":true,\"contentType\":\"markdown\"}]},{\"title\":\"Finite Automata\",\"subtopics\":[{\"title\":\"Deterministic Finite Automata (DFA)\",\"theory\":\"Let's delve into Deterministic Finite Automata (DFA), a fundamental concept within the Theory of Automata.\\n\\n### Theory of Automata: A Brief Context\\n\\nThe Theory of Automata is a branch of theoretical computer science that studies abstract machines (automata) and the computational problems that can be solved using these machines. It focuses on defining and classifying different types of computational models, understanding their capabilities and limitations, and determining what kinds of problems they can solve. One of the simplest and most widely studied of these abstract machines is the Finite Automaton, and the Deterministic Finite Automaton (DFA) is a specific type of finite automaton.\\n\\n### Deterministic Finite Automata (DFA): An Explanation\\n\\nA **Deterministic Finite Automaton (DFA)** is a mathematical model of computation that consists of a finite set of states and a set of transitions between those states. It processes an input string, one symbol at a time, and based on the current state and the input symbol, it deterministically moves to a unique next state. After processing the entire input string, if the DFA ends up in a designated \\\"final\\\" or \\\"accepting\\\" state, the string is said to be \\\"accepted\\\" by the DFA; otherwise, it is \\\"rejected.\\\"\\n\\nThe key characteristic that makes it \\\"Deterministic\\\" is that for any given state and any input symbol, there is *always exactly one* transition to a single, well-defined next state. There are no choices, no ambiguities, and no possibilities of moving to multiple states simultaneously or staying in the same state without consuming an input symbol.\\n\\n#### Formal Definition of a DFA\\n\\nA DFA is formally defined as a 5-tuple (Q, Σ, δ, q₀, F), where:\\n\\n1.  **Q (Finite Set of States):** This is a non-empty, finite set of states that the automaton can be in. Think of these as different \\\"memory configurations\\\" or \\\"stages\\\" of processing.\\n2.  **Σ (Input Alphabet):** This is a finite, non-empty set of symbols that the DFA can read as input. For example, if the DFA processes binary strings, Σ would be {0, 1}.\\n3.  **δ (Transition Function):** This is the heart of the DFA. It's a function that takes a current state and an input symbol and returns the unique next state. Formally, δ: Q × Σ → Q. This function defines all the possible moves of the automaton.\\n4.  **q₀ (Start State):** This is a single, designated state from Q where the DFA begins its processing of any input string.\\n5.  **F (Set of Final/Accepting States):** This is a subset of Q (F ⊆ Q) containing all the states where, if the DFA finishes processing an input string and lands in one of these states, the string is considered \\\"accepted\\\" by the DFA.\\n\\n#### How a DFA Works\\n\\n1.  The DFA starts in its initial state, q₀.\\n2.  It reads the input string one symbol at a time, from left to right.\\n3.  For each symbol read, it uses the transition function δ to determine the next state. If the current state is 'q' and the input symbol is 'a', the DFA transitions to state δ(q, a).\\n4.  This process continues until all symbols in the input string have been read.\\n5.  Once the entire string is processed, the DFA is in some final state. If this final state is one of the states in the set F (final states), the input string is accepted. Otherwise, if it ends in a state not in F, the string is rejected.\\n\\n### Examples of Deterministic Finite Automata\\n\\nLet's illustrate with a couple of examples.\\n\\n#### Example 1: DFA for strings ending with 'a'\\n\\nConsider a DFA that accepts all binary strings (strings composed of 'a' and 'b') that end with the symbol 'a'.\\n\\n*   **Q** = {q₀, q₁} (q₀ is the initial state, q₁ is the state reached after seeing an 'a' at the end)\\n*   **Σ** = {a, b}\\n*   **q₀** = q₀ (the start state)\\n*   **F** = {q₁} (q₁ is the only accepting state)\\n\\n*   **δ (Transition Function):**\\n    *   δ(q₀, a) = q₁ (From start, if 'a', go to q₁, meaning we just saw an 'a')\\n    *   δ(q₀, b) = q₀ (From start, if 'b', stay in q₀, because 'b' cannot be the end of an 'a'-ending string)\\n    *   δ(q₁, a) = q₁ (From q₁, if 'a', stay in q₁, meaning we still end with 'a')\\n    *   δ(q₁, b) = q₀ (From q₁, if 'b', go back to q₀, meaning the string now ends with 'b', so we are no longer in an accepting state)\\n\\nLet's trace some strings:\\n\\n*   **Input: \\\"a\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'a': δ(q₀, a) = q₁.\\n    3.  End of string. Current state is q₁. Since q₁ ∈ F, the string \\\"a\\\" is **accepted**.\\n\\n*   **Input: \\\"ba\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'b': δ(q₀, b) = q₀.\\n    3.  Read 'a': δ(q₀, a) = q₁.\\n    4.  End of string. Current state is q₁. Since q₁ ∈ F, the string \\\"ba\\\" is **accepted**.\\n\\n*   **Input: \\\"b\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'b': δ(q₀, b) = q₀.\\n    3.  End of string. Current state is q₀. Since q₀ ∉ F, the string \\\"b\\\" is **rejected**.\\n\\n*   **Input: \\\"baa\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'b': δ(q₀, b) = q₀.\\n    3.  Read 'a': δ(q₀, a) = q₁.\\n    4.  Read 'a': δ(q₁, a) = q₁.\\n    5.  End of string. Current state is q₁. Since q₁ ∈ F, the string \\\"baa\\\" is **accepted**.\\n\\n#### Example 2: DFA for strings containing \\\"ab\\\" as a substring\\n\\nConsider a DFA that accepts all binary strings (composed of 'a' and 'b') that contain the substring \\\"ab\\\" anywhere within them. Once \\\"ab\\\" is seen, the DFA stays in an accepting state.\\n\\n*   **Q** = {q₀, q₁, q₂, q₃}\\n    *   q₀: Initial state, no part of \\\"ab\\\" seen yet.\\n    *   q₁: Saw an 'a', potentially the start of \\\"ab\\\".\\n    *   q₂: Saw \\\"ab\\\", the substring is found.\\n    *   q₃: This state is not needed if q₂ is the final state and stays there. Let's refine Q to {q₀, q₁, q_accept}\\n*   **Σ** = {a, b}\\n*   **q₀** = q₀\\n*   **F** = {q_accept}\\n\\n*   **δ (Transition Function):**\\n    *   δ(q₀, a) = q₁ (From start, if 'a', move to state q₁, indicating we've seen an 'a' and are waiting for a 'b')\\n    *   δ(q₀, b) = q₀ (From start, if 'b', stay in q₀, as 'b' cannot start \\\"ab\\\")\\n    *   δ(q₁, a) = q₁ (From q₁, if 'a', stay in q₁, meaning we saw an 'a' followed by another 'a'. We are still waiting for a 'b' after the *last* 'a')\\n    *   δ(q₁, b) = q_accept (From q₁, if 'b', move to q_accept. We just saw \\\"ab\\\"!)\\n    *   δ(q_accept, a) = q_accept (Once \\\"ab\\\" is found, any subsequent input keeps us in the accepting state)\\n    *   δ(q_accept, b) = q_accept (Once \\\"ab\\\" is found, any subsequent input keeps us in the accepting state)\\n\\nLet's trace some strings:\\n\\n*   **Input: \\\"ab\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'a': δ(q₀, a) = q₁.\\n    3.  Read 'b': δ(q₁, b) = q_accept.\\n    4.  End of string. Current state is q_accept. Since q_accept ∈ F, the string \\\"ab\\\" is **accepted**.\\n\\n*   **Input: \\\"bab\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'b': δ(q₀, b) = q₀.\\n    3.  Read 'a': δ(q₀, a) = q₁.\\n    4.  Read 'b': δ(q₁, b) = q_accept.\\n    5.  End of string. Current state is q_accept. Since q_accept ∈ F, the string \\\"bab\\\" is **accepted**.\\n\\n*   **Input: \\\"b\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'b': δ(q₀, b) = q₀.\\n    3.  End of string. Current state is q₀. Since q₀ ∉ F, the string \\\"b\\\" is **rejected**.\\n\\n*   **Input: \\\"a\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'a': δ(q₀, a) = q₁.\\n    3.  End of string. Current state is q₁. Since q₁ ∉ F, the string \\\"a\\\" is **rejected**.\\n\\n*   **Input: \\\"abb\\\"**\\n    1.  Start at q₀.\\n    2.  Read 'a': δ(q₀, a) = q₁.\\n    3.  Read 'b': δ(q₁, b) = q_accept.\\n    4.  Read 'b': δ(q_accept, b) = q_accept.\\n    5.  End of string. Current state is q_accept. Since q_accept ∈ F, the string \\\"abb\\\" is **accepted**.\\n\\nDFAs are powerful enough to recognize a class of languages known as \\\"regular languages.\\\" They are widely used in practical applications such as lexical analysis in compilers (identifying keywords, identifiers, etc.), pattern matching in text editors, and designing simple control systems. Their deterministic nature makes them easy to implement and predict in their behavior.\",\"youtube\":\"\",\"image\":\"https://i.ytimg.com/vi/Y9PwXM6KN34/maxresdefault.jpg\",\"done\":false,\"contentType\":\"markdown\"},{\"title\":\"Nondeterministic Finite Automata (NFA)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"DFA Minimization\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Context-Free Languages and Pushdown Automata\",\"subtopics\":[{\"title\":\"Context-Free Grammars (CFG)\",\"theory\":\"Okay, let's break down Context-Free Grammars (CFGs) in Automata Theory.\\n\\n**What are Context-Free Grammars (CFGs)?**\\n\\nA Context-Free Grammar (CFG) is a formal system used to describe the syntax of a language. Think of it as a set of rules that define how strings can be generated in that language. \\\"Context-free\\\" means that the application of a rule doesn't depend on the surrounding symbols (the \\\"context\\\").\\n\\n**Key Components of a CFG:**\\n\\n1.  **Variables (Non-terminals):**  Represented by uppercase letters (e.g., `S`, `A`, `B`). These are placeholders that can be replaced by other variables or terminals. The starting variable, usually `S`, represents the start of the grammar.\\n\\n2.  **Terminals:**  Represented by lowercase letters or symbols (e.g., `a`, `b`, `0`, `1`). These are the actual symbols that form the strings of the language.\\n\\n3.  **Production Rules:**  These rules define how to replace variables with other variables and terminals.  A production rule has the form `Variable -> String`, where `String` is a sequence of variables and/or terminals. The `->` is read as \\\"can be replaced by.\\\"\\n\\n4.  **Start Variable:** A designated non-terminal symbol that is used to begin generating strings.\\n\\n**How CFGs Generate Strings:**\\n\\nYou start with the start variable. Then, you repeatedly apply production rules to replace variables until you have a string consisting only of terminals.  The set of all strings generated by a CFG is the language of the grammar.\\n\\n**Example 1: A Simple CFG**\\n\\nLet's say we want to define a language that consists of strings with an equal number of 'a's and 'b's, where the 'a's and 'b's can be in any order.\\n\\n*   Variables: `S`\\n*   Terminals: `a`, `b`\\n*   Production Rules:\\n    *   `S -> aSb`\\n    *   `S -> bSa`\\n    *   `S -> ε` (epsilon, representing the empty string)\\n\\nHere's how you can generate the string \\\"abba\\\":\\n\\n1.  Start with `S`\\n2.  Apply `S -> aSb`:  `aSb`\\n3.  Apply `S -> bSa`:  `abSa`\\n4.  Apply `S -> ε`: `abεa`, which simplifies to `aba`\\n5. Apply `S -> bSa`: `abbaSa`\\n6. Apply `S -> ε`: `abbaε`, which simplifies to `abba`\\n\\n**Example 2:  Arithmetic Expressions**\\n\\nCFGs are often used to define the syntax of programming languages, especially arithmetic expressions.\\n\\n*   Variables: `E` (Expression), `T` (Term), `F` (Factor)\\n*   Terminals: `+`, `*`, `(`, `)`, `id` (identifier, representing a variable name)\\n*   Production Rules:\\n    *   `E -> E + T`\\n    *   `E -> T`\\n    *   `T -> T * F`\\n    *   `T -> F`\\n    *   `F -> ( E )`\\n    *   `F -> id`\\n\\nThis grammar can generate expressions like `id + id * id` or `(id + id) * id`.\\n\\n**Key Points to Remember:**\\n\\n*   CFGs describe the *syntax* of a language, not its meaning (semantics).\\n*   A language is called \\\"context-free\\\" if there exists a CFG that generates it.\\n*   CFGs are used extensively in compiler design, parsing, and natural language processing.\\n*   The order in which you apply the production rules matters. Different orders can lead to the same string.\\n*   A string generated by a CFG has a parse tree, which shows how the string was derived from the start variable.\\n\\nIn essence, CFGs provide a structured way to specify the valid combinations of symbols that form the strings of a language.\\n\",\"youtube\":\"\",\"image\":\"https://ds055uzetaobb.cloudfront.net/brioche/uploads/YZjIA0gLXU-cfg.png?width\\\\u003d1200\",\"done\":false,\"contentType\":\"markdown\"},{\"title\":\"Pushdown Automata (PDA)\",\"theory\":\"Okay, let's break down Pushdown Automata (PDA) in Automata Theory.\\n\\n**What is a Pushdown Automata (PDA)?**\\n\\nA Pushdown Automata is a theoretical machine used to recognize formal languages. It's an extension of a Finite Automata (FA) with an added component: a stack. Think of it like a FA (which has states and transitions based on input) but with the ability to store and retrieve information from a stack. This stack gives the PDA \\\"memory\\\" to handle more complex patterns than a FA can.\\n\\n**Key Components of a PDA:**\\n\\n1.  **States:** Similar to a Finite Automata, a PDA has a finite set of states representing the machine's configuration.\\n\\n2.  **Input Alphabet:** The set of symbols the PDA can read as input.\\n\\n3.  **Stack Alphabet:** The set of symbols that can be pushed onto and popped from the stack. This can be different from the input alphabet.\\n\\n4.  **Transition Function:** This function dictates how the PDA moves between states and manipulates the stack based on the current state, the input symbol being read, and the symbol on the top of the stack. The transition function defines the rules of the automaton.\\n\\n5.  **Start State:** The initial state of the PDA.\\n\\n6.  **Accept State(s):** One or more states that, if reached, indicate that the input string has been accepted (recognized as part of the language).\\n\\n7.  **Start Stack Symbol:** A specific symbol initially placed on the stack.\\n\\n**How a PDA Works: The Process**\\n\\n1.  **Input Reading:** The PDA reads the input string one symbol at a time, from left to right.\\n\\n2.  **State Transitions:** Based on the current state, the current input symbol, and the symbol at the top of the stack, the PDA transitions to a new state. The transition is defined by the transition function.\\n\\n3.  **Stack Operations:** As part of a transition, the PDA can perform operations on the stack:\\n\\n    *   **Push:** Add a symbol to the top of the stack.\\n    *   **Pop:** Remove the symbol from the top of the stack.\\n    *   **No Operation:** The stack can remain unchanged.\\n\\n4.  **Acceptance:** The PDA accepts the input string if it reaches an accept state after processing the entire input. Acceptance can also sometimes be defined by an empty stack.\\n\\n**Example 1: Recognizing the Language {w c w<sup>R</sup> | w is a string of a's and b's, and w<sup>R</sup> is the reverse of w}**\\n\\nThis language consists of strings like \\\"abcba\\\", \\\"aabbccbbaa\\\". The 'c' acts as a middle marker.\\n\\n*   **How a PDA handles it:**\\n    1.  The PDA reads the first part of the string ('w', consisting of a's and b's).\\n    2.  For each 'a' or 'b' read, it pushes the symbol onto the stack. The stack builds a representation of 'w'.\\n    3.  When the PDA reads the 'c', it knows it's at the middle.\\n    4.  Now, for each symbol read after 'c', it compares it to the symbol at the top of the stack.\\n    5.  If they match, it pops the symbol from the stack.\\n    6.  If they don't match, the PDA rejects the string.\\n    7.  If the PDA reaches the end of the input string and the stack is empty, it accepts the string.\\n\\n**Example 2: Recognizing Balanced Parentheses (e.g., \\\"(()())\\\")**\\n\\n*   **How a PDA handles it:**\\n    1.  For each left parenthesis '(' read, the PDA pushes a symbol (e.g., '$') onto the stack.\\n    2.  For each right parenthesis ')' read, the PDA pops a symbol from the stack.\\n    3.  If the PDA encounters a ')' and the stack is empty, it rejects the string (because there's no matching '(').\\n    4.  If the PDA reaches the end of the input and the stack is empty, it accepts the string (all parentheses are balanced).\\n    5.  If the PDA reaches the end of the input and the stack is not empty, it rejects the string (because there are unmatched '(' characters).\\n\\n**Why PDAs are Important**\\n\\nPDAs are essential for recognizing context-free languages, which are more powerful than the regular languages that Finite Automata can handle. Context-free languages are used in parsing programming languages, describing the structure of documents (like HTML), and many other areas of computer science. The stack gives the PDA the ability to \\\"remember\\\" information about what it has seen so far, which is crucial for recognizing nested structures and matching patterns.\\n\",\"youtube\":\"\",\"image\":\"https://i.ytimg.com/vi/4ejIAmp_Atw/maxresdefault.jpg\",\"done\":false,\"contentType\":\"markdown\"},{\"title\":\"CYK Algorithm\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Turing Machines and Computability\",\"subtopics\":[{\"title\":\"Deterministic Turing Machines\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Nondeterministic Turing Machines\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Halting Problem\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]}]}",
            "type": "Text & Image Course",
            "mainTopic": "theory of automata",
            "slug": "theory-of-automata",
            "photo": "https://images.unsplash.com/photo-1743962789636-77bb3f889b7d?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w1NDM1MTN8MHwxfHNlYXJjaHwxfHx0aGVvcnklMjBvZiUyMGF1dG9tYXRhfGVufDB8MHx8fDE3NjIxMDg0NjV8MA&ixlib=rb-4.1.0&q=80&w=1080",
            "completed": false,
            "date": "2025-11-02T18:34:26.252Z",
            "end": "2025-11-02T18:34:26.252Z"
        }
    ],
    "pagination": {
        "currentPage": 1,
        "totalPages": 1,
        "totalItems": 3,
        "hasNext": false,
        "hasPrev": false
    }
}