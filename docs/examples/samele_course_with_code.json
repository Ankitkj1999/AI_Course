[
  {
    "_id": "68f6347ba1d9c3c14e060ad9",
    "user": "68d593ab8f080eae321d2b31",
    "content": "{\"top searching algorithms (javascript code)\":[{\"title\":\"Linear Search\",\"subtopics\":[{\"title\":\"Basic Implementation\",\"theory\":\"Okay, let's break down the \\\"Basic Implementation\\\" of common searching algorithms in JavaScript. This means focusing on the core logic without optimizations or complex data structures. We'll cover Linear Search and Binary Search.\\n\\n**1. Linear Search (Sequential Search)**\\n\\n*   **Concept:** Linear search is the simplest. It iterates through each element of an array one by one until it finds the target value. If the target is not present, it will reach the end of the array.\\n\\n*   **JavaScript Code:**\\n\\n    ```javascript\\n    function linearSearch(array, target) {\\n      for (let i = 0; i < array.length; i++) {\\n        if (array[i] === target) {\\n          return i; // Return the index if found\\n        }\\n      }\\n      return -1; // Return -1 if not found\\n    }\\n\\n    // Example Usage:\\n    const myArray = [5, 2, 9, 1, 5, 6];\\n    const targetValue = 9;\\n    const result = linearSearch(myArray, targetValue);\\n\\n    if (result !== -1) {\\n      console.log(\\\"Element found at index: \\\" + result); // Output: Element found at index: 2\\n    } else {\\n      console.log(\\\"Element not found.\\\");\\n    }\\n    ```\\n\\n*   **Explanation:**\\n\\n    1.  The `linearSearch` function takes an array and a `target` value as input.\\n    2.  It loops through the array using a `for` loop.\\n    3.  Inside the loop, it checks if the current element (`array[i]`) is equal to the `target`.\\n    4.  If a match is found, the function immediately returns the index `i` where the element was found.\\n    5.  If the loop completes without finding the `target`, the function returns `-1` to indicate that the element is not present in the array.\\n\\n**2. Binary Search**\\n\\n*   **Concept:** Binary search is more efficient but **requires the input array to be sorted**. It works by repeatedly dividing the search interval in half. If the middle element is the target, the search is complete. If the target is smaller than the middle element, the search continues in the left half. Otherwise, the search continues in the right half.\\n\\n*   **JavaScript Code:**\\n\\n    ```javascript\\n    function binarySearch(array, target) {\\n      let left = 0;\\n      let right = array.length - 1;\\n\\n      while (left <= right) {\\n        const mid = Math.floor((left + right) / 2); // Calculate the middle index\\n\\n        if (array[mid] === target) {\\n          return mid; // Target found at the middle\\n        } else if (array[mid] < target) {\\n          left = mid + 1; // Target is in the right half\\n        } else {\\n          right = mid - 1; // Target is in the left half\\n        }\\n      }\\n\\n      return -1; // Target not found\\n    }\\n\\n    // Example Usage (Array MUST be sorted):\\n    const sortedArray = [2, 5, 7, 8, 11, 12];\\n    const targetValue = 12;\\n    const result = binarySearch(sortedArray, targetValue);\\n\\n    if (result !== -1) {\\n      console.log(\\\"Element found at index: \\\" + result); // Output: Element found at index: 5\\n    } else {\\n      console.log(\\\"Element not found.\\\");\\n    }\\n    ```\\n\\n*   **Explanation:**\\n\\n    1.  The `binarySearch` function takes a *sorted* array and a `target` value.\\n    2.  `left` and `right` pointers are initialized to the start and end indices of the array.\\n    3.  The `while` loop continues as long as the `left` pointer is less than or equal to the `right` pointer.\\n    4.  Inside the loop:\\n        *   `mid` is calculated as the middle index.  `Math.floor()` ensures it's an integer.\\n        *   If `array[mid]` is equal to the `target`, the function returns `mid`.\\n        *   If `array[mid]` is less than the `target`, it means the target must be in the right half of the array.  The `left` pointer is updated to `mid + 1`.\\n        *   If `array[mid]` is greater than the `target`, the target must be in the left half.  The `right` pointer is updated to `mid - 1`.\\n    5.  If the `while` loop finishes without finding the target, the function returns `-1`.\\n\\n**Key Differences:**\\n\\n*   **Sorting:** Binary search *requires* a sorted array. Linear search does not.\\n*   **Efficiency:** Binary search is much faster for large, sorted arrays (O(log n) time complexity) compared to linear search (O(n) time complexity).  However, the overhead of sorting the array (if it's not already sorted) should be considered when choosing an algorithm.\\n*   **Applicability:** Linear search can be used on unsorted data, whereas binary search cannot.\\n\",\"youtube\":\"\",\"image\":\"https://media.geeksforgeeks.org/wp-content/uploads/20240506155201/binnary-search-.webp\",\"done\":false},{\"title\":\"Time Complexity\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"JavaScript Code Example\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Use Cases\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Binary Search\",\"subtopics\":[{\"title\":\"Iterative Implementation\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Recursive Implementation\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Time Complexity\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"JavaScript Code Example\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Pre-requisites (Sorted Array)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Jump Search\",\"subtopics\":[{\"title\":\"Algorithm Explanation\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Block Size Optimization\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Time Complexity\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"JavaScript Code Example\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"When to use Jump Search\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]},{\"title\":\"Depth-First Search (DFS)\",\"subtopics\":[{\"title\":\"Graph Traversal\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Recursive Implementation\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Iterative Implementation (using Stack)\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"JavaScript Code Example\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false},{\"title\":\"Use Cases: Path Finding, Cycle Detection\",\"theory\":\"\",\"youtube\":\"\",\"image\":\"\",\"done\":false}]}]}",
    "type": "Text & Image Course",
    "mainTopic": "top searching algorithms (javascript code)",
    "slug": "top-searching-algorithms-javascript-code",
    "photo": "https://images.unsplash.com/photo-1649451844931-57e22fc82de3?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w1NDM1MTN8MHwxfHNlYXJjaHwxfHx0b3AlMjBzZWFyY2hpbmclMjBhbGdvcml0aG1zJTIwJTI4amF2YXNjcmlwdCUyMGNvZGUlMjl8ZW58MHwwfHx8MTc2MDk2NTc1NXww&ixlib=rb-4.1.0&q=80&w=1080",
    "completed": false,
    "date": "2025-10-20T13:09:15.672Z",
    "end": "2025-10-20T13:09:15.672Z",
    "__v": 0
  }
]