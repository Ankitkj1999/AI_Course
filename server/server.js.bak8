// IMPORT
import express from "express";
import mongoose from "mongoose";
import bodyParser from "body-parser";
import nodemailer from "nodemailer";
import cors from "cors";
import crypto from "crypto";
import jwt from "jsonwebtoken";
import dotenv from "dotenv";
import cookieParser from "cookie-parser";
import gis from "g-i-s";
import youtubesearchapi from "youtube-search-api";
import { YoutubeTranscript } from "youtube-transcript";
import {
  GoogleGenerativeAI,
  HarmBlockThreshold,
  HarmCategory,
} from "@google/generative-ai";
import { createApi } from "unsplash-js";
import showdown from "showdown";
import axios from "axios";
import Stripe from "stripe";
import Flutterwave from "flutterwave-node-v3";
import logger from "./utils/logger.js";
import errorHandler from "./middleware/errorHandler.js";
import {
  generateSlug,
  generateUniqueSlug,
  extractTitleFromContent,
} from "./utils/slugify.js";
import Settings from "./models/Settings.js";
import DocumentProcessing from "./models/DocumentProcessing.js";
import {
  Course,
  Section,
  Notes,
  Exam,
  Language,
  User,
  Admin,
  Subscription,
  Contact,
  Blog,
  Quiz,
  Flashcard,
  Guide
} from "./models/index.js";
import settingsCache from "./services/settingsCache.js";
import {
  requireAuth,
  requireAdmin,
  requireMainAdmin,
  optionalAuth
} from "./middleware/authMiddleware.js";
import authRoutes from "./routes/authRoutes.js";
import adminRoutes from "./routes/adminRoutes.js";
import paymentRoutes from "./routes/paymentRoutes.js";
import userRoutes from "./routes/userRoutes.js";
import contentGenerationRoutes from "./routes/contentGenerationRoutes.js";
import utilityRoutes from "./routes/utilityRoutes.js";
import llmRoutes, { initializeLlmRoutes } from "./routes/llmRoutes.js";
import courseRoutes from "./routes/courseRoutes.js";
import { generateCourseSEO } from "./utils/seo.js";
import { getServerPort, getServerURL, validateConfig } from "./utils/config.js";
import llmService from "./services/llmService.js";
import { safeGet, safeGetArray, safeGetFirst } from "./utils/safeAccess.js";
import { uploadSingle, uploadConfig } from "./middleware/uploadMiddleware.js";
import {
  extractDocument,
  extractFromURL,
} from "./services/documentExtraction.js";
import { cleanupFile } from "./services/fileCleanup.js";
import fs from "fs/promises";
import path from "path";
import apiRoutes from "./routes/apiRoutes.js";
import databaseOptimizationService from "./services/databaseOptimization.js";
import cachingService from "./services/cachingService.js";
import relatedModelMigrationService from "./services/relatedModelMigration.js";
import fixLexicalContent from "./scripts/fixLexicalContent.js";

// NOTE: Google Generative AI SDK is still available for future advanced features
// such as Gemini Live APIs, Deep Research, Google Search integration, etc.
// Currently using LangChain for standardized multi-model support.

// Load environment variables
dotenv.config();

// Validate configuration
validateConfig();

// Initialize services that need config
let stripe = null;
let flw = null;

try {
  if (process.env.STRIPE_SECRET_KEY) {
    stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
    logger.info('âœ… Stripe initialized');
  } else {
    logger.warn('âš ï¸  Stripe not configured - payment features will be limited');
  }
} catch (error) {
  logger.error('âŒ Stripe initialization failed:', error.message);
}

try {
  if (process.env.FLUTTERWAVE_PUBLIC_KEY && process.env.FLUTTERWAVE_SECRET_KEY) {
    flw = new Flutterwave(
      process.env.FLUTTERWAVE_PUBLIC_KEY,
      process.env.FLUTTERWAVE_SECRET_KEY
    );
    logger.info('âœ… Flutterwave initialized');
  } else {
    logger.warn('âš ï¸  Flutterwave not configured - payment features will be limited');
  }
} catch (error) {
  logger.error('âŒ Flutterwave initialization failed:', error.message);
}

//INITIALIZE
const app = express();

// Configure CORS - Simplified for Docker setup
const corsOptions = {
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);

    // Allow all localhost origins in development
    if (process.env.NODE_ENV !== "production") {
      const localhostRegex = /^https?:\/\/(localhost|127\.0\.0\.1):\d+$/;
      if (localhostRegex.test(origin)) {
        logger.info(`CORS: Allowing development origin: ${origin}`);
        return callback(null, true);
      }
    }

    // Get allowed origins from environment or use defaults
    const envOrigins = process.env.ALLOWED_ORIGINS
      ? process.env.ALLOWED_ORIGINS.split(",")
      : [];

    const allowedOrigins = [
      process.env.WEBSITE_URL,
      `http://localhost:${process.env.PORT}`,
      `https://localhost:${process.env.PORT}`,
      "http://localhost:5010",
      "https://localhost:5010",
      // Production domains
      "https://gksage.com",
      "https://www.gksage.com",
      "http://gksage.com",
      "http://www.gksage.com",
      // Additional origins from environment
      ...envOrigins,
    ].filter(Boolean);

    // Also allow any localhost origin and production domains
    const isLocalhost = /^https?:\/\/(localhost|127\.0\.0\.1)(:\d+)?$/.test(
      origin
    );
    const isProductionDomain = /^https?:\/\/(www\.)?gksage\.com$/.test(origin);

    if (allowedOrigins.includes(origin) || isLocalhost || isProductionDomain) {
      logger.info(`CORS: Allowing origin: ${origin}`);
      callback(null, true);
    } else {
      logger.warn(`CORS: Blocked origin: ${origin}`);
      callback(new Error(`Origin ${origin} not allowed by CORS`));
    }
  },
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"],
  credentials: true,
};

app.use(cors(corsOptions));

// Handle preflight requests
app.options("*", cors(corsOptions));

// Logging middleware
app.use((req, res, next) => {
  logger.http(`${req.method} ${req.url} - ${req.ip}`);
  next();
});

const PORT = process.env.PORT;
app.use(bodyParser.json({ limit: "50mb" }));
app.use(express.json({ limit: "50mb" }));
app.use(cookieParser());
mongoose.connect(process.env.MONGODB_URI, {
  serverSelectionTimeoutMS: 30000, // 30 seconds
  socketTimeoutMS: 45000, // 45 seconds
  maxPoolSize: 10,
  minPoolSize: 2,
  retryWrites: true,
  retryReads: true,
});

// MongoDB connection event handlers
mongoose.connection.on("connected", async () => {
  logger.info("MongoDB connected successfully");
  
  // Temporarily disable startup functions to isolate the issue
  /*
  try {
    // Initialize database optimizations
    await databaseOptimizationService.initializeIndexes();
    logger.info("Database indexes initialized");
    
    // Run related model migration
    await relatedModelMigrationService.migrateExistingData();
    logger.info("Related model migration completed");
    
    // Fix any invalid Lexical content
    await fixLexicalContent();
    logger.info("Lexical content cleanup completed");
    
  } catch (error) {
    logger.error("Startup initialization error:", error);
  }
  */
});

mongoose.connection.on("error", (err) => {
  logger.error("MongoDB connection error:", err);
});

mongoose.connection.on("disconnected", () => {
  logger.warn("MongoDB disconnected");
});

const unsplash = createApi({ accessKey: process.env.UNSPLASH_ACCESS_KEY });

// All Mongoose schemas are now defined in separate model files in the models/ directory
// Models are imported from models/index.js at the top of this file

// Authentication middleware is imported from middleware/authMiddleware.js
// Authentication routes are mounted from routes/authRoutes.js

//REQUEST

// Mount authentication routes
app.use('/api', authRoutes);

// Mount admin routes
app.use('/api', adminRoutes);

// Mount payment routes
app.use('/api', paymentRoutes);

// Mount user profile routes
app.use('/api', userRoutes);

// Mount content generation routes
app.use('/api', contentGenerationRoutes);

// Initialize and mount LLM routes
initializeLlmRoutes({ llmService, logger, requireAuth });
app.use('/api', llmRoutes);

// Mount course routes
app.use('/api/courses', courseRoutes);

// Mount utility routes
app.use('/api', utilityRoutes);

//STORE COURSE (Enhanced with new section-based architecture)
app.post("/api/course", requireAuth, async (req, res) => {
  const { user, content, type, mainTopic, lang, isPublic } = req.body;

  // ğŸ” DIAGNOSTIC: Log what content is being received
  console.log('ğŸ” DIAGNOSTIC - /api/course received:', {
    user,
    mainTopic,
    type,
    lang,
    isPublic,
    contentLength: content?.length,
    contentPreview: content?.substring(0, 200)
  });
  
  // Parse content to check if it has theory
  try {
    const parsedContent = JSON.parse(content);
    const firstKey = Object.keys(parsedContent)[0];
    const firstTopic = parsedContent[firstKey]?.[0];
    const firstSubtopic = firstTopic?.subtopics?.[0];
    
    console.log('ğŸ” DIAGNOSTIC - Parsed content structure:', {
      hasContent: !!parsedContent,
      firstKey,
      firstTopicTitle: firstTopic?.title,
      firstSubtopicTitle: firstSubtopic?.title,
      firstSubtopicHasTheory: !!firstSubtopic?.theory,
      firstSubtopicTheoryLength: firstSubtopic?.theory?.length || 0,
      firstSubtopicTheoryPreview: firstSubtopic?.theory?.substring(0, 100)
    });
  } catch (e) {
    console.log('ğŸ” DIAGNOSTIC - Could not parse content:', e.message);
  }

  // Generate request ID for logging correlation
  const requestId = logger.llm.generateRequestId();
  const startTime = Date.now();

  // Log request start
  logger.llm.logRequestStart(
    requestId,
    "/api/course",
    {
      mainTopic,
      type,
      contentLength: content?.length,
      lang,
    },
    user,
    "unsplash"
  );

  try {
    console.log('â±ï¸ TIMING - Starting Unsplash API call...');
    const unsplashStartTime = Date.now();
    
    // Add timeout to Unsplash API call
    const unsplashPromise = unsplash.search.getPhotos({
      query: mainTopic,
      page: 1,
      perPage: 1,
      orientation: "landscape",
    });
    
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Unsplash timeout')), 5000)
    );
    
    const result = await Promise.race([unsplashPromise, timeoutPromise]);
    
    console.log(`â±ï¸ TIMING - Unsplash API completed in ${Date.now() - unsplashStartTime}ms`);

    // Safely access Unsplash response with fallback
    const photos = safeGetArray(result, "response.results", []);
    const firstPhoto = safeGetFirst(result, "response.results");
    const photo = safeGet(firstPhoto, "urls.regular", null);

    // Log if Unsplash API returned unexpected data
    if (!photo) {
      logger.llm.logValidationFailure(
        requestId,
        "/api/course",
        {
          expected: "response.results[0].urls.regular",
          issue: "No usable images returned",
        },
        {
          hasResponse: !!safeGet(result, "response"),
          hasResults: !!safeGet(result, "response.results"),
          resultsLength: safeGetArray(result, "response.results", []).length,
          mainTopic,
        }
      );
    }

    try {
      console.log('â±ï¸ TIMING - Starting course generation service...');
      const courseGenStartTime = Date.now();
      
      // Import CourseGenerationService
      const { default: CourseGenerationService } = await import('./services/courseGenerationService.js');
      
      // Use the new CourseGenerationService to create course with sections
      const newCourse = await CourseGenerationService.createCourseFromGeneration({
        content,
        type,
        mainTopic,
        photo,
        lang,
        isPublic: isPublic ?? false,
        generationMeta: {
          userPrompt: mainTopic,
          model: 'ai-generated',
          generatedAt: new Date()
        }
      }, user);
      
      console.log(`â±ï¸ TIMING - Course generation completed in ${Date.now() - courseGenStartTime}ms`);
      
      // Create language record with better error handling
      try {
        const newLang = new Language({ 
          userId: user, 
          courseId: newCourse._id, 
          lang: lang,
          course: newCourse.slug // Maintain backward compatibility
        });
        await newLang.save();
      } catch (langError) {
        // Log language creation error but don't fail the course creation
        logger.llm.logRequestError(requestId, "/api/course", langError, {
          userId: user,
          courseId: newCourse._id,
          lang,
          step: "language_creation",
        });
        console.warn('Language record creation failed:', langError.message);
      }

      const duration = Date.now() - startTime;
      
      console.log(`â±ï¸ TIMING - Total /api/course execution: ${duration}ms`);
      console.log(`â±ï¸ BREAKDOWN:`, {
        unsplashTime: 'see above',
        courseGenerationTime: 'see above',
        totalTime: `${duration}ms`,
        sectionsCreated: newCourse.sections.length
      });

      // Log successful course creation
      logger.llm.logRequestSuccess(
        requestId,
        "/api/course",
        {
          courseId: newCourse._id,
          slug: newCourse.slug,
          hasPhoto: !!photo,
          mainTopic,
          isPublic: newCourse.isPublic,
          sectionsCreated: newCourse.sections.length,
          newArchitecture: true,
          totalDuration: duration
        },
        duration,
        user,
        "unsplash"
      );

      res.json({
        success: true,
        message: "Course created successfully with new architecture",
        courseId: newCourse._id,
        slug: newCourse.slug,
        isPublic: newCourse.isPublic,
        sectionsCreated: newCourse.sections.length,
        architecture: 'section-based',
        performanceMs: duration
      });
    } catch (error) {
      // Log course creation error with context
      logger.llm.logRequestError(requestId, "/api/course", error, {
        userId: user,
        mainTopic,
        hasPhoto: !!photo,
        step: "course_generation",
        errorDetails: {
          name: error.name,
          message: error.message,
          code: error.code,
          stack: error.stack
        }
      });
      
      console.error('Course generation error:', {
        error: error.message,
        name: error.name,
        code: error.code,
        user,
        mainTopic
      });
      
      res
        .status(500)
        .json({ success: false, message: "Course generation failed", error: error.message });
    }
  } catch (error) {
    // Handle Unsplash API errors gracefully
    logger.llm.logRequestError(requestId, "/api/course", error, {
      userId: user,
      mainTopic,
      unsplashQuery: mainTopic,
      step: "unsplash_api",
    });

    // Continue course creation without photo
    try {
      // Import CourseGenerationService
      const { default: CourseGenerationService } = await import('./services/courseGenerationService.js');
      
      // Use the new CourseGenerationService to create course with sections (no photo)
      const newCourse = await CourseGenerationService.createCourseFromGeneration({
        content,
        type,
        mainTopic,
        photo: null,
        lang,
        isPublic: isPublic ?? false,
        generationMeta: {
          userPrompt: mainTopic,
          model: 'ai-generated',
          generatedAt: new Date()
        }
      }, user);
      
      // Create language record with better error handling
      try {
        const newLang = new Language({ 
          userId: user, 
          courseId: newCourse._id, 
          lang: lang,
          course: newCourse.slug // Maintain backward compatibility
        });
        await newLang.save();
      } catch (langError) {
        // Log language creation error but don't fail the course creation
        logger.llm.logRequestError(requestId, "/api/course", langError, {
          userId: user,
          courseId: newCourse._id,
          lang,
          step: "fallback_language_creation",
        });
        console.warn('Language record creation failed in fallback:', langError.message);
      }

      const duration = Date.now() - startTime;

      // Log successful fallback course creation
      logger.llm.logRequestSuccess(
        requestId,
        "/api/course",
        {
          courseId: newCourse._id,
          slug: newCourse.slug,
          hasPhoto: false,
          mainTopic,
          fallback: true,
          sectionsCreated: newCourse.sections.length,
          newArchitecture: true
        },
        duration,
        user,
        "fallback"
      );

      res.json({
        success: true,
        message: "Course created successfully with new architecture (without image)",
        courseId: newCourse._id,
        slug: newCourse.slug,
        sectionsCreated: newCourse.sections.length,
        architecture: 'section-based'
      });
    } catch (courseError) {
      // Log fallback course creation error
      logger.llm.logRequestError(requestId, "/api/course", courseError, {
        userId: user,
        mainTopic,
        step: "fallback_course_generation",
        errorDetails: {
          name: courseError.name,
          message: courseError.message,
          code: courseError.code,
          stack: courseError.stack
        }
      });
      
      console.error('Fallback course generation error:', {
        error: courseError.message,
        name: courseError.name,
        code: courseError.code,
        user,
        mainTopic
      });
      
      res
        .status(500)
        .json({ success: false, message: "Course generation failed", error: courseError.message });
    }
  }
});

//STORE COURSE SHARED
app.post("/api/courseshared", requireAuth, async (req, res) => {
  const { user, content, type, mainTopic } = req.body;

  try {
    const result = await unsplash.search.getPhotos({
      query: mainTopic,
      page: 1,
      perPage: 1,
      orientation: "landscape",
    });

    // Safely access Unsplash response with fallback
    const photos = safeGetArray(result, "response.results", []);
    const firstPhoto = safeGetFirst(result, "response.results");
    const photo = safeGet(firstPhoto, "urls.regular", null);

    // Log if Unsplash API returned unexpected data
    if (!photo) {
      logger.warn(
        `Unsplash API returned no usable images for shared course topic: ${mainTopic}`,
        {
          unsplashResponse: {
            hasResponse: !!safeGet(result, "response"),
            hasResults: !!safeGet(result, "response.results"),
            resultsLength: safeGetArray(result, "response.results", []).length,
          },
        }
      );
    }

    try {
      // Generate SEO-friendly slug for shared course
      const title = extractTitleFromContent(content, mainTopic);
      const slug = await generateUniqueSlug(title, Course);

      const newCourse = new Course({
        user,
        content,
        type,
        mainTopic,
        slug,
        photo,
      });
      await newCourse.save();

      logger.info(
        `Shared course created: ${newCourse._id} with slug: ${slug}`,
        {
          hasPhoto: !!photo,
          mainTopic,
        }
      );
      res.json({
        success: true,
        message: "Course created successfully",
        courseId: newCourse._id,
        slug: slug,
      });
    } catch (error) {
      logger.error(`Shared course creation error: ${error.message}`, {
        error: error.stack,
        user,
        mainTopic,
      });
      res
        .status(500)
        .json({ success: false, message: "Internal server error" });
    }
  } catch (error) {
    // Handle Unsplash API errors gracefully
    logger.error(
      `Unsplash API error for shared course creation: ${error.message}`,
      {
        error: error.stack,
        user,
        mainTopic,
        unsplashQuery: mainTopic,
      }
    );

    // Continue course creation without photo
    try {
      const title = extractTitleFromContent(content, mainTopic);
      const slug = await generateUniqueSlug(title, Course);

      const newCourse = new Course({
        user,
        content,
        type,
        mainTopic,
        slug,
        photo: null,
      });
      await newCourse.save();

      logger.info(
        `Shared course created without photo due to Unsplash error: ${newCourse._id} with slug: ${slug}`
      );
      res.json({
        success: true,
        message: "Course created successfully (without image)",
        courseId: newCourse._id,
        slug: slug,
      });
    } catch (courseError) {
      logger.error(
        `Shared course creation fallback error: ${courseError.message}`,
        {
          error: courseError.stack,
          user,
          mainTopic,
        }
      );
      res
        .status(500)
        .json({ success: false, message: "Internal server error" });
    }
  }
});

//CONVERT LEGACY COURSE TO NEW FORMAT
app.post("/api/course/convert/:courseId", requireAuth, async (req, res) => {
  try {
    const { courseId } = req.params;
    const userId = req.user.id;
    
    // Import CourseGenerationService
    const { default: CourseGenerationService } = await import('./services/courseGenerationService.js');
    
    // Convert the legacy course
    const convertedCourse = await CourseGenerationService.convertLegacyCourse(courseId, userId);
    
    res.json({
      success: true,
      message: "Course successfully converted to new architecture",
      courseId: convertedCourse._id,
      slug: convertedCourse.slug,
      sectionsCreated: convertedCourse.sections.length,
      architecture: 'section-based'
    });
    
  } catch (error) {
    console.error('Course conversion error:', error);
    res.status(500).json({
      success: false,
      message: error.message || "Course conversion failed"
    });
  }
});

//GET COURSE ARCHITECTURE INFO
app.get("/api/course/architecture/:courseId", requireAuth, async (req, res) => {
  try {
    const { courseId } = req.params;
    const userId = req.user.id;
    
    const course = await Course.findById(courseId);
    if (!course) {
      return res.status(404).json({
        success: false,
        message: "Course not found"
      });
    }
    
    // Check if user owns the course
    if (course.user !== userId) {
      return res.status(403).json({
        success: false,
        message: "Access denied"
      });
    }
    
    // Import CourseGenerationService
    const { default: CourseGenerationService } = await import('./services/courseGenerationService.js');
    
    const isNew = CourseGenerationService.isNewArchitecture(course);
    const isLegacy = CourseGenerationService.isLegacyCourse(course);
    
    res.json({
      success: true,
      courseId: course._id,
      title: course.title,
      architecture: {
        isNewArchitecture: isNew,
        isLegacyCourse: isLegacy,
        hasContent: !!course.content,
        hasSections: course.sections && course.sections.length > 0,
        sectionCount: course.sections ? course.sections.length : 0,
        needsMigration: isLegacy
      },
      generationMeta: course.generationMeta
    });
    
  } catch (error) {
    console.error('Get course architecture error:', error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to get course architecture info"
    });
  }
});

//GET COURSE GENERATION STATS
app.get("/api/course/stats/:courseId", requireAuth, async (req, res) => {
  try {
    const { courseId } = req.params;
    
    // Import CourseGenerationService
    const { default: CourseGenerationService } = await import('./services/courseGenerationService.js');
    
    // Get generation statistics
    const stats = await CourseGenerationService.getGenerationStats(courseId);
    
    res.json({
      success: true,
      stats
    });
    
  } catch (error) {
    console.error('Get course stats error:', error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to get course statistics"
    });
  }
});

//UPDATE SECTION CONTENT (New Architecture)
app.post("/api/sections/:sectionId/content", requireAuth, async (req, res) => {
  const { sectionId } = req.params;
  const { content, contentType = "markdown", metadata = {} } = req.body;
  
  console.log('ğŸ“ Section Content Update Request:', {
    sectionId,
    contentLength: content?.length || 0,
    contentType,
    metadataKeys: Object.keys(metadata),
    userId: req.user._id.toString()
  });
  
  try {
    // Import required services
    const { default: SectionService } = await import('./services/sectionService.js');
    const { default: ContentConverter } = await import('./services/contentConverter.js');
    
    // Get the section and verify ownership
    const section = await SectionService.getSection(sectionId);
    if (!section) {
      console.log('âŒ Section not found:', sectionId);
      return res.status(404).json({ success: false, message: "Section not found" });
    }
    
    console.log('ğŸ“„ Found section:', {
      sectionId: section._id,
      title: section.title,
      courseId: section.courseId,
      hasExistingContent: !!section.content
    });
    
    // Verify user has access to this course
    const Course = (await import('./models/Course.js')).default;
    const course = await Course.findById(section.courseId);
    if (!course || course.user !== req.user._id.toString()) {
      console.log('âŒ Access denied for user:', req.user._id.toString());
      return res.status(403).json({ success: false, message: "Access denied" });
    }
    
    let updateData = {};
    
    // If content is provided, convert it to multi-format structure
    if (content !== undefined) {
      console.log('ğŸ”„ Converting content to multi-format...');
      const convertedContent = await ContentConverter.convertToMultiFormat(content, contentType);
      console.log('âœ… Content converted:', {
        hasMarkdown: !!convertedContent.markdown?.text,
        hasHtml: !!convertedContent.html?.text,
        primaryFormat: convertedContent.primaryFormat,
        markdownLength: convertedContent.markdown?.text?.length || 0,
        htmlLength: convertedContent.html?.text?.length || 0
      });
      updateData.content = convertedContent;
    }
    
    // If metadata is provided, merge it with existing metadata
    if (Object.keys(metadata).length > 0) {
      const existingMetadata = section.content?.metadata || {};
      updateData['content.metadata'] = { ...existingMetadata, ...metadata };
      console.log('ğŸ“‹ Metadata merged:', {
        existing: Object.keys(existingMetadata),
        new: Object.keys(metadata),
        merged: Object.keys(updateData['content.metadata'])
      });
    }
    
    console.log('ğŸ’¾ Updating section with data:', {
      hasContent: !!updateData.content,
      hasMetadata: !!updateData['content.metadata']
    });
    
    // Update section content
    const updatedSection = await SectionService.updateSection(sectionId, updateData);
    
    console.log('âœ… Section updated successfully:', {
      sectionId: updatedSection._id,
      hasContent: !!updatedSection.content,
      contentStructure: updatedSection.content ? {
        hasMarkdown: !!updatedSection.content.markdown?.text,
        hasHtml: !!updatedSection.content.html?.text,
        primaryFormat: updatedSection.content.primaryFormat,
        hasMetadata: !!updatedSection.content.metadata
      } : null
    });
    
    res.json({ 
      success: true, 
      message: "Section content updated successfully",
      section: updatedSection
    });
    
  } catch (error) {
    console.error("âŒ Section content update error:", error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

//GET COURSE PROGRESS (New Architecture)
app.get("/api/course/:courseId/progress", requireAuth, async (req, res) => {
  try {
    const { courseId } = req.params;
    const userId = req.user._id.toString();
    
    // Get course
    const course = await Course.findById(courseId);
    if (!course) {
      return res.status(404).json({
        success: false,
        message: "Course not found"
      });
    }
    
    // Check access permissions
    const isOwner = course.user === userId;
    const isPublic = course.isPublic === true;
    
    if (!isPublic && !isOwner) {
      return res.status(403).json({
        success: false,
        message: "Access denied"
      });
    }
    
    // Get sections for progress calculation
    const sections = await Section.find({ courseId: courseId });
    const totalSections = sections.length;
    const completedSections = sections.filter(s => s.content?.metadata?.done).length;
    const progressPercentage = totalSections > 0 ? Math.round((completedSections / totalSections) * 100) : 0;
    
    // Get language preference
    const language = await Language.findOne({ courseId: courseId, userId: userId });
    
    res.json({
      success: true,
      courseId: course._id,
      progress: {
        completed: completedSections,
        total: totalSections,
        percentage: progressPercentage,
        isCompleted: course.completed || false
      },
      language: language?.lang || 'english',
      course: {
        _id: course._id,
        title: course.title || course.mainTopic,
        mainTopic: course.mainTopic,
        slug: course.slug,
        type: course.type,
        photo: course.photo,
        isPublic: course.isPublic,
        createdAt: course.date,
        // Convert to legacy format for compatibility
        content: course.content || null
      }
    });
    
  } catch (error) {
    logger.error("Get course progress error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error"
    });
  }
});

//GET COURSE HIERARCHY (New Architecture)
app.get("/api/v2/courses/:courseId/hierarchy", requireAuth, async (req, res) => {
  try {
    const { courseId } = req.params;
    const { includeContent = false } = req.query;
    const userId = req.user._id.toString();
    
    // Get course
    const course = await Course.findById(courseId);
    if (!course) {
      return res.status(404).json({
        success: false,
        message: "Course not found"
      });
    }
    
    // Check access permissions
    const isOwner = course.user === userId;
    const isPublic = course.isPublic === true;
    
    if (!isPublic && !isOwner) {
      return res.status(403).json({
        success: false,
        message: "Access denied"
      });
    }
    
    // Get all sections for this course
    const sections = await Section.find({ courseId: courseId })
      .sort({ order: 1, createdAt: 1 });
    
    // Build hierarchical structure
    const rootSections = sections.filter(s => !s.parentId);
    
    const buildHierarchy = (parentSections) => {
      return parentSections.map(section => {
        const children = sections.filter(s => 
          s.parentId && s.parentId.toString() === section._id.toString()
        );
        
        const sectionData = {
          _id: section._id,
          title: section.title,
          order: section.order,
          level: section.level || 1,
          hasChildren: children.length > 0,
          createdAt: section.createdAt
        };
        
        // Include content if requested
        if (includeContent === 'true') {
          sectionData.content = section.content;
        }
        
        // Recursively build children
        if (children.length > 0) {
          sectionData.children = buildHierarchy(children);
        }
        
        return sectionData;
      });
    };
    
    const hierarchy = buildHierarchy(rootSections);
    
    res.json({
      success: true,
      courseId: course._id,
      course: {
        _id: course._id,
        title: course.title || course.mainTopic,
        mainTopic: course.mainTopic,
        slug: course.slug,
        type: course.type,
        photo: course.photo,
        isPublic: course.isPublic,
        createdAt: course.date
      },
      hierarchy: hierarchy,
      totalSections: sections.length,
      rootSections: rootSections.length
    });
    
  } catch (error) {
    logger.error("Get course hierarchy error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error"
    });
  }
});

//UPDATE COURSE
//DELETE COURSE
app.post("/api/deletecourse", async (req, res) => {
  const { courseId } = req.body;
  try {
    await Course.findOneAndDelete({ _id: courseId });
    res.json({ success: true, message: "Course deleted successfully" });
  } catch (error) {
    console.log(error);
    return res.json({ success: false, message: "Internal Server Error" });
  }
});

app.post("/api/finish", async (req, res) => {
  const { courseId } = req.body;
  try {
    await Course.findOneAndUpdate(
      { _id: courseId },
      { $set: { completed: true, end: Date.now() } }
    )
      .then((result) => {
        res.json({ success: true, message: "Course completed successfully" });
      })
      .catch((error) => {
        console.log("Error", error);
        res
          .status(500)
          .json({ success: false, message: "Internal server error" });
      });
  } catch (error) {
    console.log("Error", error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

// Backend: Modify API to handle pagination
    }
    
    // Import CourseGenerationService to check architecture
    const { default: CourseGenerationService } = await import('./services/courseGenerationService.js');
    
    const isNewArchitecture = CourseGenerationService.isNewArchitecture(course);
    const isLegacy = CourseGenerationService.isLegacyCourse(course);
    
    if (isNewArchitecture) {
      // Get sections for new architecture
      const sections = await Section.find({ courseId: courseId })
        .sort({ order: 1, createdAt: 1 });
      
      res.json({
        success: true,
        architecture: 'section-based',
        course: {
          _id: course._id,
          title: course.title || course.mainTopic,
          slug: course.slug,
          mainTopic: course.mainTopic,
          type: course.type,
          photo: course.photo,
          isPublic: course.isPublic,
          createdAt: course.date,
          generationMeta: course.generationMeta
        },
        sections: sections.map(section => ({
          _id: section._id,
          title: section.title,
          order: section.order,
          parentId: section.parentId,
          level: section.level,
          content: {
            markdown: section.content.markdown,
            html: section.content.html,
            lexical: section.content.lexical
          },
          metadata: section.metadata,
          createdAt: section.createdAt
        })),
        sectionCount: sections.length
      });
    } else if (isLegacy) {
      // Return legacy course with migration suggestion
      res.json({
        success: true,
        architecture: 'legacy',
        course: {
          _id: course._id,
          title: course.title || course.mainTopic,
          slug: course.slug,
          mainTopic: course.mainTopic,
          type: course.type,
          photo: course.photo,
          isPublic: course.isPublic,
          content: course.content, // Legacy content
          createdAt: course.date
        },
        sections: [],
        sectionCount: 0,
        migrationAvailable: true,
        message: "This course uses legacy architecture. Consider converting to section-based format."
      });
    } else {
      // Empty course
      res.json({
        success: true,
        architecture: 'empty',
        course: {
          _id: course._id,
          title: course.title || course.mainTopic,
          slug: course.slug,
          mainTopic: course.mainTopic,
          type: course.type,
          photo: course.photo,
          isPublic: course.isPublic,
          createdAt: course.date
        },
        sections: [],
        sectionCount: 0,
        message: "Course has no content yet."
      });
    }
    
  } catch (error) {
    logger.error("Get course content error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error"
    });
  }
});

//GET COURSE BY ID (Legacy support)
//GET SEO DATA FOR COURSE
app.get("/api/seo/course/:slug", async (req, res) => {
  try {
    const { slug } = req.params;
    const course = await Course.findOne({ slug });

    if (!course) {
      return res.status(404).json({
        success: false,
        message: "Course not found",
      });
    }

    const baseUrl = process.env.WEBSITE_URL || "http://localhost:8080";
    const seoData = generateCourseSEO(course, baseUrl);

    res.json({
      success: true,
      seo: seoData,
    });
  } catch (error) {
    logger.error(`Get SEO data error: ${error.message}`, {
      error: error.stack,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

//GET PROFILE DETAILS
app.post("/api/profile", async (req, res) => {
  const { email, mName, password, uid } = req.body;
  try {
    if (password === "") {
      await User.findOneAndUpdate(
        { _id: uid },
        { $set: { email: email, mName: mName } }
      )
        .then((result) => {
          res.json({ success: true, message: "Profile Updated" });
        })
        .catch((error) => {
          res
            .status(500)
            .json({ success: false, message: "Internal server error" });
        });
    } else {
      await User.findOneAndUpdate(
        { _id: uid },
        { $set: { email: email, mName: mName, password: password } }
      )
        .then((result) => {
          res.json({ success: true, message: "Profile Updated" });
        })
        .catch((error) => {
          res
            .status(500)
            .json({ success: false, message: "Internal server error" });
        });
    }
  } catch (error) {
    console.log("Error", error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

// Payment routes are now in routes/paymentRoutes.js

// Admin routes are now in routes/adminRoutes.js

//GET NOTES
app.post("/api/getnotes", async (req, res) => {
  const { course } = req.body;
  try {
    const existingNotes = await Notes.findOne({ course: course });
    if (userDetails.method === "stripe") {
      const subscription = await stripe.subscriptions.retrieve(
        userDetails.subscriberId
      );

      res.json({ session: subscription, method: userDetails.method });
    } else if (userDetails.method === "paypal") {
      const PAYPAL_CLIENT_ID = process.env.PAYPAL_CLIENT_ID;
      const PAYPAL_APP_SECRET_KEY = process.env.PAYPAL_APP_SECRET_KEY;
      const auth = Buffer.from(
        PAYPAL_CLIENT_ID + ":" + PAYPAL_APP_SECRET_KEY
      ).toString("base64");
      const response = await fetch(
        `https://api-m.paypal.com/v1/billing/subscriptions/${userDetails.subscription}`,
        {
          headers: {
            Authorization: "Basic " + auth,
            "Content-Type": "application/json",
            Accept: "application/json",
          },
        }
      );
      const session = await response.json();
      res.json({ session: session, method: userDetails.method });
    } else if (userDetails.method === "flutterwave") {
      const payload = { email: email };
      if (!flw) {
        res.status(500).json({ success: false, message: "Flutterwave not configured" });
        return;
      }
      if (!flw) {
        res.status(500).json({ success: false, message: "Flutterwave not configured" });
        return;
      }
      const response = await flw.Subscription.get(payload);
      res.json({ session: response["data"][0], method: userDetails.method });
    } else if (userDetails.method === "paystack") {
      const authorization = `Bearer ${process.env.PAYSTACK_SECRET_KEY}`;
      const response = await axios.get(
        `https://api.paystack.co/subscription/${userDetails.subscriberId}`,
        {
          headers: {
            Authorization: authorization,
          },
        }
      );

      let subscriptionDetails = null;
      subscriptionDetails = {
        subscription_code: response.data.data.subscription_code,
        createdAt: response.data.data.createdAt,
        updatedAt: response.data.data.updatedAt,
        customer_code: userDetails.subscription,
        email_token: response.data.data.email_token,
      };

      res.json({ session: subscriptionDetails, method: userDetails.method });
    } else {
      const YOUR_KEY_ID = process.env.RAZORPAY_KEY_ID;
      const YOUR_KEY_SECRET = process.env.RAZORPAY_KEY_SECRET;
      const SUBSCRIPTION_ID = userDetails.subscription;

      const config = {
        headers: {
          "Content-Type": "application/json",
        },
        auth: {
          username: YOUR_KEY_ID,
          password: YOUR_KEY_SECRET,
        },
      };

      axios
        .get(
          `https://api.razorpay.com/v1/subscriptions/${SUBSCRIPTION_ID}`,
          config
        )
        .then((response) => {
          res.json({ session: response.data, method: userDetails.method });
        })
        .catch((error) => {
          console.log(error);
        });
    }
  } catch (error) {
    console.log("Error", error);
  }
});

app.post("/api/downloadreceipt", async (req, res) => {
  const { html, email } = req.body;

  const transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 465,
    service: "gmail",
    secure: true,
    auth: {
      user: process.env.EMAIL,
      pass: process.env.PASSWORD,
    },
  });

  const options = {
    from: process.env.EMAIL,
    to: email,
    subject: "Subscription Receipt",
    html: html,
  };

  transporter.sendMail(options, (error, info) => {
    if (error) {
      console.log("Error", error);
      res
        .status(500)
        .json({ success: false, message: "Failed to send receipt" });
    } else {
      res.json({ success: true, message: "Receipt sent to your mail" });
    }
  });
});

//SEND RECEIPT
app.post("/api/sendreceipt", async (req, res) => {
  const { html, email, plan, subscriberId, user, method, subscription } =
    req.body;
  console.log(subscriberId, subscription);
  const existingSubscription = await Subscription.findOne({ user: user });
  if (existingSubscription) {
    //DO NOTHING
  } else {
    const newSub = new Subscription({
      user,
      subscription,
      subscriberId,
      plan,
      method,
    });
    await newSub.save();
    console.log(newSub);
  }

  const transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 465,
    service: "gmail",
    secure: true,
    auth: {
      user: process.env.EMAIL,
      pass: process.env.PASSWORD,
    },
  });

  const options = {
    from: process.env.EMAIL,
    to: email,
    subject: "Subscription Payment",
    html: html,
  };

  transporter.sendMail(options, (error, info) => {
    if (error) {
      console.log("Error", error);
      res
        .status(500)
        .json({ success: false, message: "Failed to send receipt" });
    } else {
      res.json({ success: true, message: "Receipt sent to your mail" });
    }
  });
});

//PAYPAL WEBHOOKS
app.post("/api/paypalwebhooks", async (req, res) => {
  const body = req.body;
  const event_type = body.event_type;

  switch (event_type) {
    case "BILLING.SUBSCRIPTION.CANCELLED":
      const id = body["resource"]["id"];
      updateSubsciption(id, "Cancelled");
      break;
    case "BILLING.SUBSCRIPTION.EXPIRED":
      const id2 = body["resource"]["id"];
      updateSubsciption(id2, "Expired");
      break;
    case "BILLING.SUBSCRIPTION.SUSPENDED":
      const id3 = body["resource"]["id"];
      updateSubsciption(id3, "Suspended");
      break;
    case "BILLING.SUBSCRIPTION.PAYMENT.FAILED":
      const id4 = body["resource"]["id"];
      updateSubsciption(id4, "Disabled Due To Payment Failure");
      break;
    case "PAYMENT.SALE.COMPLETED":
      const id5 = body["resource"]["billing_agreement_id"];
      sendRenewEmail(id5);
      break;

    default:
    //DO NOTHING
  }
});

//SEND RENEW EMAIL
async function sendRenewEmail(id) {
  try {
    const subscriptionDetails = await Subscription.findOne({
      subscription: id,
    });
    const userId = subscriptionDetails.user;
    const userDetails = await User.findOne({ _id: userId });

    const transporter = nodemailer.createTransport({
      host: "smtp.gmail.com",
      port: 465,
      service: "gmail",
      secure: true,
      auth: {
        user: process.env.EMAIL,
        pass: process.env.PASSWORD,
      },
    });

    const mailOptions = {
      from: process.env.EMAIL,
      to: userDetails.email,
      subject: `${userDetails.mName} Your Subscription Plan Has Been Renewed`,
      html: `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
            <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
            <html lang="en">
            
              <head></head>
             <div id="__react-email-preview" style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Subscription Renewed<div> â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿</div>
             </div>
            
             <body style="padding:20px; margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;background-color:#f6f9fc;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;">
                    <table align="center" role="presentation" cellSpacing="0" cellPadding="0" border="0" height="80%" width="100%" style="max-width:37.5em;max-height:80%; margin-left:auto;margin-right:auto;margin-top:80px;margin-bottom:80px;width:465px;border-radius:0.25rem;border-width:1px;background-color:#fff;padding:20px">
                  <tr style="width:100%">
                    <td>
                      <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-top:32px">
                        <tbody>
                          <tr>
                            <td><img alt="Vercel" src="${process.env.LOGO}" width="40" height="37" style="display:block;outline:none;border:none;text-decoration:none;margin-left:auto;margin-right:auto;margin-top:0px;margin-bottom:0px" /></td>
                          </tr>
                        </tbody>
                      </table>
                      <h1 style="margin-left:0px;margin-right:0px;margin-top:30px;margin-bottom:30px;padding:0px;text-align:center;font-size:24px;font-weight:400;color:rgb(0,0,0)">Subscription Renewed</h1>
                      <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">${userDetails.mName}, your subscription plan has been Renewed.</p>
                      <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-bottom:32px;margin-top:32px;text-align:center">
                      </table>
                      <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">Best,<p target="_blank" style="color:rgb(0,0,0);text-decoration:none;text-decoration-line:none">The <strong>${process.env.COMPANY}</strong> Team</p></p>
                      </td>
                  </tr>
                </table>
              </body>
            
            </html>`,
    };

    await transporter.sendMail(mailOptions);
  } catch (error) {
    console.log("Error", error);
  }
}

//UPDATE SUBSCRIPTION DETIALS
async function updateSubsciption(id, subject) {
  try {
    const subscriptionDetails = await Subscription.findOne({
      subscription: id,
    });
    const userId = subscriptionDetails.user;

    await User.findOneAndUpdate({ _id: userId }, { $set: { type: "free" } });

    const userDetails = await User.findOne({ _id: userId });
    await Subscription.findOneAndDelete({ subscription: id });

    sendCancelEmail(userDetails.email, userDetails.mName, subject);
  } catch (error) {
    console.log("Error", error);
  }
}

//SEND CANCEL EMAIL
async function sendCancelEmail(email, name, subject) {
  const transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 465,
    service: "gmail",
    secure: true,
    auth: {
      user: process.env.EMAIL,
      pass: process.env.PASSWORD,
    },
  });

  const Reactivate = process.env.WEBSITE_URL + "/pricing";

  const mailOptions = {
    from: process.env.EMAIL,
    to: email,
    subject: `${name} Your Subscription Plan Has Been ${subject}`,
    html: `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
        <html lang="en">
        
          <head></head>
         <div id="__react-email-preview" style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Subscription ${subject}<div> â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿</div>
         </div>
        
<body style="padding:20px; margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;background-color:#f6f9fc;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;">
                    <table align="center" role="presentation" cellSpacing="0" cellPadding="0" border="0" height="80%" width="100%" style="max-width:37.5em;max-height:80%; margin-left:auto;margin-right:auto;margin-top:80px;margin-bottom:80px;width:465px;border-radius:0.25rem;border-width:1px;background-color:#fff;padding:20px">
              <tr style="width:100%">
                <td>
                  <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-top:32px">
                    <tbody>
                      <tr>
                        <td><img alt="Vercel" src="${process.env.LOGO}" width="40" height="37" style="display:block;outline:none;border:none;text-decoration:none;margin-left:auto;margin-right:auto;margin-top:0px;margin-bottom:0px" /></td>
                      </tr>
                    </tbody>
                  </table>
                  <h1 style="margin-left:0px;margin-right:0px;margin-top:30px;margin-bottom:30px;padding:0px;text-align:center;font-size:24px;font-weight:400;color:rgb(0,0,0)">Subscription ${subject}</h1>
                  <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">${name}, your subscription plan has been ${subject}. Reactivate your plan by clicking on the button below.</p>
                  <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-bottom:32px;margin-top:32px;text-align:center">
                       <tbody>
                          <tr>
                            <td><a href="${Reactivate}" target="_blank" style="p-x:20px;p-y:12px;line-height:100%;text-decoration:none;display:inline-block;max-width:100%;padding:12px 20px;border-radius:0.25rem;background-color: #a855f7;text-align:center;font-size:12px;font-weight:600;color:rgb(255,255,255);text-decoration-line:none"><span></span><span style="p-x:20px;p-y:12px;max-width:100%;display:inline-block;line-height:120%;text-decoration:none;text-transform:none;mso-padding-alt:0px;mso-text-raise:9px"</span><span>Reactivate</span></a></td>
                          </tr>
                        </tbody>
                  </table>
                  <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">Best,<p target="_blank" style="color:rgb(0,0,0);text-decoration:none;text-decoration-line:none">The <strong>${process.env.COMPANY}</strong> Team</p></p>
                  </td>
              </tr>
            </table>
          </body>
        
        </html>`,
  };

  await transporter.sendMail(mailOptions);
}

//CANCEL PAYPAL SUBSCRIPTION
app.post("/api/paypalcancel", async (req, res) => {
  const { id, email } = req.body;

  const PAYPAL_CLIENT_ID = process.env.PAYPAL_CLIENT_ID;
  const PAYPAL_APP_SECRET_KEY = process.env.PAYPAL_APP_SECRET_KEY;
  const auth = Buffer.from(
    PAYPAL_CLIENT_ID + ":" + PAYPAL_APP_SECRET_KEY
  ).toString("base64");
  await fetch(
    `https://api-m.paypal.com/v1/billing/subscriptions/${id}/cancel`,
    {
      method: "POST",
      headers: {
        Authorization: "Basic " + auth,
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify({ reason: "Not satisfied with the service" }),
    }
  ).then(async (resp) => {
    try {
      const subscriptionDetails = await Subscription.findOne({
        subscriberId: email,
      });
      const userId = subscriptionDetails.user;

      await User.findOneAndUpdate({ _id: userId }, { $set: { type: "free" } });

      const userDetails = await User.findOne({ _id: userId });
      await Subscription.findOneAndDelete({ subscription: id });

      const transporter = nodemailer.createTransport({
        host: "smtp.gmail.com",
        port: 465,
        service: "gmail",
        secure: true,
        auth: {
          user: process.env.EMAIL,
          pass: process.env.PASSWORD,
        },
      });

      const Reactivate = process.env.WEBSITE_URL + "/pricing";

      const mailOptions = {
        from: process.env.EMAIL,
        to: userDetails.email,
        subject: `${userDetails.mName} Your Subscription Plan Has Been Cancelled`,
        html: `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
                <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
                <html lang="en">
                
                  <head></head>
                 <div id="__react-email-preview" style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Subscription Cancelled<div> â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿</div>
                 </div>
                
<body style="padding:20px; margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;background-color:#f6f9fc;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;">
                    <table align="center" role="presentation" cellSpacing="0" cellPadding="0" border="0" height="80%" width="100%" style="max-width:37.5em;max-height:80%; margin-left:auto;margin-right:auto;margin-top:80px;margin-bottom:80px;width:465px;border-radius:0.25rem;border-width:1px;background-color:#fff;padding:20px">
                      <tr style="width:100%">
                        <td>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-top:32px">
                            <tbody>
                              <tr>
                                <td><img alt="Vercel" src="${process.env.LOGO}" width="40" height="37" style="display:block;outline:none;border:none;text-decoration:none;margin-left:auto;margin-right:auto;margin-top:0px;margin-bottom:0px" /></td>
                              </tr>
                            </tbody>
                          </table>
                          <h1 style="margin-left:0px;margin-right:0px;margin-top:30px;margin-bottom:30px;padding:0px;text-align:center;font-size:24px;font-weight:400;color:rgb(0,0,0)">Subscription Cancelled</h1>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">${userDetails.mName}, your subscription plan has been Cancelled. Reactivate your plan by clicking on the button below.</p>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-bottom:32px;margin-top:32px;text-align:center">
                               <tbody>
                                  <tr>
                                    <td><a href="${Reactivate}" target="_blank" style="p-x:20px;p-y:12px;line-height:100%;text-decoration:none;display:inline-block;max-width:100%;padding:12px 20px;border-radius:0.25rem;background-color: #a855f7;text-align:center;font-size:12px;font-weight:600;color:rgb(255,255,255);text-decoration-line:none"><span></span><span style="p-x:20px;p-y:12px;max-width:100%;display:inline-block;line-height:120%;text-decoration:none;text-transform:none;mso-padding-alt:0px;mso-text-raise:9px"</span><span>Reactivate</span></a></td>
                                  </tr>
                                </tbody>
                          </table>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">Best,<p target="_blank" style="color:rgb(0,0,0);text-decoration:none;text-decoration-line:none">The <strong>${process.env.COMPANY}</strong> Team</p></p>
                          </td>
                      </tr>
                    </table>
                  </body>
                
                </html>`,
      };

      await transporter.sendMail(mailOptions);
      res.json({ success: true, message: "" });
    } catch (error) {
      console.log("Error", error);
    }
  });
});

//UPDATE SUBSCRIPTION
app.post("/api/paypalupdate", async (req, res) => {
  const { id, idPlan } = req.body;

  const PAYPAL_CLIENT_ID = process.env.PAYPAL_CLIENT_ID;
  const PAYPAL_APP_SECRET_KEY = process.env.PAYPAL_APP_SECRET_KEY;
  const auth = Buffer.from(
    PAYPAL_CLIENT_ID + ":" + PAYPAL_APP_SECRET_KEY
  ).toString("base64");

  try {
    const response = await fetch(
      `https://api-m.paypal.com/v1/billing/subscriptions/${id}/revise`,
      {
        method: "POST",
        headers: {
          Authorization: "Basic " + auth,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          plan_id: idPlan,
          application_context: {
            brand_name: process.env.COMPANY,
            locale: "en-US",
            payment_method: {
              payer_selected: "PAYPAL",
              payee_preferred: "IMMEDIATE_PAYMENT_REQUIRED",
            },
            return_url: `${process.env.WEBSITE_URL}/payment-success/${idPlan}`,
            cancel_url: `${process.env.WEBSITE_URL}/payment-failed`,
          },
        }),
      }
    );
    const session = await response.json();
    res.send(session);
  } catch (error) {
    console.log("Error", error);
  }
});

//UPDATE SUBSCRIPTION AND USER DETAILS
app.post("/api/paypalupdateuser", async (req, res) => {
  const { id, mName, email, user, plan } = req.body;

  await Subscription.findOneAndUpdate(
    { subscription: id },
    { $set: { plan: plan } }
  ).then(async (r) => {
    await User.findOneAndUpdate({ _id: user }, { $set: { type: plan } }).then(
      async (ress) => {
        const transporter = nodemailer.createTransport({
          host: "smtp.gmail.com",
          port: 465,
          service: "gmail",
          secure: true,
          auth: {
            user: process.env.EMAIL,
            pass: process.env.PASSWORD,
          },
        });

        const mailOptions = {
          from: process.env.EMAIL,
          to: email,
          subject: `${mName} Your Subscription Plan Has Been Modifed`,
          html: `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
                <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
                <html lang="en">
    
                  <head></head>
                 <div id="__react-email-preview" style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Subscription Modifed<div> â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿</div>
                 </div>
    
    <body style="padding:20px; margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;background-color:#f6f9fc;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;">
                    <table align="center" role="presentation" cellSpacing="0" cellPadding="0" border="0" height="80%" width="100%" style="max-width:37.5em;max-height:80%; margin-left:auto;margin-right:auto;margin-top:80px;margin-bottom:80px;width:465px;border-radius:0.25rem;border-width:1px;background-color:#fff;padding:20px">
                      <tr style="width:100%">
                        <td>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-top:32px">
                            <tbody>
                              <tr>
                                <td><img alt="Vercel" src="${process.env.LOGO}" width="40" height="37" style="display:block;outline:none;border:none;text-decoration:none;margin-left:auto;margin-right:auto;margin-top:0px;margin-bottom:0px" /></td>
                              </tr>
                            </tbody>
                          </table>
                          <h1 style="margin-left:0px;margin-right:0px;margin-top:30px;margin-bottom:30px;padding:0px;text-align:center;font-size:24px;font-weight:400;color:rgb(0,0,0)">Subscription Modifed</h1>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">${mName}, your subscription plan has been Modifed.</p>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-bottom:32px;margin-top:32px;text-align:center">
                          </table>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">Best,<p target="_blank" style="color:rgb(0,0,0);text-decoration:none;text-decoration-line:none">The <strong>${process.env.COMPANY}</strong> Team</p></p>
                          </td>
                      </tr>
                    </table>
                  </body>
    
                </html>`,
        };

        await transporter.sendMail(mailOptions);
      }
    );
  });
});

//CREATE RAZORPAY SUBSCRIPTION
app.post("/api/razorpaycreate", async (req, res) => {
  const { plan, email, fullAddress } = req.body;
  try {
    const YOUR_KEY_ID = process.env.RAZORPAY_KEY_ID;
    const YOUR_KEY_SECRET = process.env.RAZORPAY_KEY_SECRET;

    const requestBody = {
      plan_id: plan,
      total_count: 12,
      quantity: 1,
      customer_notify: 1,
      notes: {
        notes_key_1: fullAddress,
      },
      notify_info: {
        notify_email: email,
      },
    };

    const config = {
      headers: {
        "Content-Type": "application/json",
      },
      auth: {
        username: YOUR_KEY_ID,
        password: YOUR_KEY_SECRET,
      },
    };

    const requestData = JSON.stringify(requestBody);

    axios
      .post("https://api.razorpay.com/v1/subscriptions", requestData, config)
      .then((response) => {
        res.send(response.data);
      })
      .catch((error) => {
        console.log("Error", error);
      });
  } catch (error) {
    console.log("Error", error);
  }
});

//GET RAZORPAY SUBSCRIPTION DETAILS
app.post("/api/razorapydetails", async (req, res) => {
  const { subscriberId, uid, plan } = req.body;

  let cost = 0;
  if (plan === process.env.MONTH_TYPE) {
    cost = process.env.MONTH_COST;
  } else {
    cost = process.env.YEAR_COST;
  }
  cost = cost / 4;

  await Admin.findOneAndUpdate({ type: "main" }, { $inc: { total: cost } });

  await User.findOneAndUpdate({ _id: uid }, { $set: { type: plan } })
    .then(async (result) => {
      const YOUR_KEY_ID = process.env.RAZORPAY_KEY_ID;
      const YOUR_KEY_SECRET = process.env.RAZORPAY_KEY_SECRET;
      const SUBSCRIPTION_ID = subscriberId;

      const config = {
        headers: {
          "Content-Type": "application/json",
        },
        auth: {
          username: YOUR_KEY_ID,
          password: YOUR_KEY_SECRET,
        },
      };

      axios
        .get(
          `https://api.razorpay.com/v1/subscriptions/${SUBSCRIPTION_ID}`,
          config
        )
        .then((response) => {
          res.send(response.data);
        })
        .catch((error) => {
          //DO NOTHING
        });
    })
    .catch((error) => {
      res
        .status(500)
        .json({ success: false, message: "Internal server error" });
    });
});

//RAZORPAY PENDING
app.post("/api/razorapypending", async (req, res) => {
  const { sub } = req.body;

  const YOUR_KEY_ID = process.env.RAZORPAY_KEY_ID;
  const YOUR_KEY_SECRET = process.env.RAZORPAY_KEY_SECRET;
  const SUBSCRIPTION_ID = sub;

  const config = {
    headers: {
      "Content-Type": "application/json",
    },
    auth: {
      username: YOUR_KEY_ID,
      password: YOUR_KEY_SECRET,
    },
  };

  axios
    .get(`https://api.razorpay.com/v1/subscriptions/${SUBSCRIPTION_ID}`, config)
    .then((response) => {
      res.send(response.data);
    })
    .catch((error) => {
      console.log("Error", error);
    });
});

//RAZORPAY CANCEL SUBSCRIPTION
app.post("/api/razorpaycancel", async (req, res) => {
  const { id, email } = req.body;

  const YOUR_KEY_ID = process.env.RAZORPAY_KEY_ID;
  const YOUR_KEY_SECRET = process.env.RAZORPAY_KEY_SECRET;
  const SUBSCRIPTION_ID = id;

  const requestBody = {
    cancel_at_cycle_end: 0,
  };

  const config = {
    headers: {
      "Content-Type": "application/json",
    },
    auth: {
      username: YOUR_KEY_ID,
      password: YOUR_KEY_SECRET,
    },
  };

  axios
    .post(
      `https://api.razorpay.com/v1/subscriptions/${SUBSCRIPTION_ID}/cancel`,
      requestBody,
      config
    )
    .then(async (resp) => {
      try {
        const subscriptionDetails = await Subscription.findOne({
          subscriberId: email,
        });
        const userId = subscriptionDetails.user;

        await User.findOneAndUpdate(
          { _id: userId },
          { $set: { type: "free" } }
        );

        const userDetails = await User.findOne({ _id: userId });
        await Subscription.findOneAndDelete({ subscription: id });

        const transporter = nodemailer.createTransport({
          host: "smtp.gmail.com",
          port: 465,
          service: "gmail",
          secure: true,
          auth: {
            user: process.env.EMAIL,
            pass: process.env.PASSWORD,
          },
        });

        const Reactivate = process.env.WEBSITE_URL + "/pricing";

        const mailOptions = {
          from: process.env.EMAIL,
          to: userDetails.email,
          subject: `${userDetails.mName} Your Subscription Plan Has Been Cancelled`,
          html: `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
                    <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
                    <html lang="en">
                    
                      <head></head>
                     <div id="__react-email-preview" style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Subscription Cancelled<div> â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿</div>
                     </div>
                    
<body style="padding:20px; margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;background-color:#f6f9fc;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;">
                    <table align="center" role="presentation" cellSpacing="0" cellPadding="0" border="0" height="80%" width="100%" style="max-width:37.5em;max-height:80%; margin-left:auto;margin-right:auto;margin-top:80px;margin-bottom:80px;width:465px;border-radius:0.25rem;border-width:1px;background-color:#fff;padding:20px">
                          <tr style="width:100%">
                            <td>
                              <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-top:32px">
                                <tbody>
                                  <tr>
                                    <td><img alt="Vercel" src="${process.env.LOGO}" width="40" height="37" style="display:block;outline:none;border:none;text-decoration:none;margin-left:auto;margin-right:auto;margin-top:0px;margin-bottom:0px" /></td>
                                  </tr>
                                </tbody>
                              </table>
                              <h1 style="margin-left:0px;margin-right:0px;margin-top:30px;margin-bottom:30px;padding:0px;text-align:center;font-size:24px;font-weight:400;color:rgb(0,0,0)">Subscription Cancelled</h1>
                              <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">${userDetails.mName}, your subscription plan has been Cancelled. Reactivate your plan by clicking on the button below.</p>
                              <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-bottom:32px;margin-top:32px;text-align:center">
                                   <tbody>
                                      <tr>
                                        <td><a href="${Reactivate}" target="_blank" style="p-x:20px;p-y:12px;line-height:100%;text-decoration:none;display:inline-block;max-width:100%;padding:12px 20px;border-radius:0.25rem;background-color: #a855f7;text-align:center;font-size:12px;font-weight:600;color:rgb(255,255,255);text-decoration-line:none"><span></span><span style="p-x:20px;p-y:12px;max-width:100%;display:inline-block;line-height:120%;text-decoration:none;text-transform:none;mso-padding-alt:0px;mso-text-raise:9px"</span><span>Reactivate</span></a></td>
                                      </tr>
                                    </tbody>
                              </table>
                              <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">Best,<p target="_blank" style="color:rgb(0,0,0);text-decoration:none;text-decoration-line:none">The <strong>${process.env.COMPANY}</strong> Team</p></p>
                              </td>
                          </tr>
                        </table>
                      </body>
                    
                    </html>`,
        };

        await transporter.sendMail(mailOptions);
        res.json({ success: true, message: "" });
      } catch (error) {
        console.log("Error", error);
      }
    })
    .catch((error) => {
      console.log("Error", error);
    });
});

//CONTACT
app.post("/api/contact", async (req, res) => {
  const { fname, lname, email, phone, msg } = req.body;
  try {
    const newContact = new Contact({ fname, lname, email, phone, msg });
    await newContact.save();
    res.json({ success: true, message: "Submitted" });
  } catch (error) {
    console.log("Error", error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

// Admin routes are now in routes/adminRoutes.js

//GET PUBLIC SETTINGS (for client-side use)
app.get("/api/public/settings", async (req, res) => {
  try {
    const settings = await Settings.find({ isSecret: false });
    const publicSettings = {};

    settings.forEach((setting) => {
      publicSettings[setting.key] = {
        value: setting.value,
        category: setting.category,
        isSecret: setting.isSecret,
      };
    });

    res.json(publicSettings);
  } catch (error) {
    console.error("Public settings fetch error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

//STRIPE PAYMENT
app.post("/api/stripepayment", async (req, res) => {
  const { planId } = req.body;

  try {
    const session = await stripe.checkout.sessions.create({
      success_url: `${process.env.WEBSITE_URL}/payment-success/${planId}`,
      cancel_url: `${process.env.WEBSITE_URL}/payment-failed`,
      line_items: [
        {
          price: planId,
          quantity: 1,
        },
      ],
      mode: "subscription",
    });

    res.json({ url: session.url, id: session.id });
  } catch (e) {
    console.log("Error", e);
    res.status(500).json({ error: e.message });
  }
});

app.post("/api/stripedetails", async (req, res) => {
  const { subscriberId, uid, plan } = req.body;

  let cost = 0;
  if (plan === process.env.MONTH_TYPE) {
    cost = process.env.MONTH_COST;
  } else {
    cost = process.env.YEAR_COST;
  }
  cost = cost / 4;

  await Admin.findOneAndUpdate({ type: "main" }, { $inc: { total: cost } });

  await User.findOneAndUpdate({ _id: uid }, { $set: { type: plan } })
    .then(async (result) => {
      const session = await stripe.checkout.sessions.retrieve(subscriberId);
      res.send(session);
    })
    .catch((error) => {
      console.log("Error", error);
      res
        .status(500)
        .json({ success: false, message: "Internal server error" });
    });
});

app.post("/api/stripecancel", async (req, res) => {
  const { id, email } = req.body;

  const subscription = await stripe.subscriptions.cancel(id);

  try {
    const subscriptionDetails = await Subscription.findOne({
      subscriberId: email,
    });
    const userId = subscriptionDetails.user;

    await User.findOneAndUpdate({ _id: userId }, { $set: { type: "free" } });

    const userDetails = await User.findOne({ _id: userId });
    await Subscription.findOneAndDelete({ subscriberId: id });

    const transporter = nodemailer.createTransport({
      host: "smtp.gmail.com",
      port: 465,
      service: "gmail",
      secure: true,
      auth: {
        user: process.env.EMAIL,
        pass: process.env.PASSWORD,
      },
    });

    const Reactivate = process.env.WEBSITE_URL + "/pricing";

    const mailOptions = {
      from: process.env.EMAIL,
      to: userDetails.email,
      subject: `${userDetails.mName} Your Subscription Plan Has Been Cancelled`,
      html: `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
                <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
                <html lang="en">
                
                  <head></head>
                 <div id="__react-email-preview" style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Subscription Cancelled<div> â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿</div>
                 </div>

<body style="padding:20px; margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;background-color:#f6f9fc;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;">
                    <table align="center" role="presentation" cellSpacing="0" cellPadding="0" border="0" height="80%" width="100%" style="max-width:37.5em;max-height:80%; margin-left:auto;margin-right:auto;margin-top:80px;margin-bottom:80px;width:465px;border-radius:0.25rem;border-width:1px;background-color:#fff;padding:20px">
                      <tr style="width:100%">
                        <td>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-top:32px">
                            <tbody>
                              <tr>
                                <td><img alt="Vercel" src="${process.env.LOGO}" width="40" height="37" style="display:block;outline:none;border:none;text-decoration:none;margin-left:auto;margin-right:auto;margin-top:0px;margin-bottom:0px" /></td>
                              </tr>
                            </tbody>
                          </table>
                          <h1 style="margin-left:0px;margin-right:0px;margin-top:30px;margin-bottom:30px;padding:0px;text-align:center;font-size:24px;font-weight:400;color:rgb(0,0,0)">Subscription Cancelled</h1>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">${userDetails.mName}, your subscription plan has been Cancelled. Reactivate your plan by clicking on the button below.</p>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-bottom:32px;margin-top:32px;text-align:center">
                               <tbody>
                                  <tr>
                                    <td><a href="${Reactivate}" target="_blank" style="p-x:20px;p-y:12px;line-height:100%;text-decoration:none;display:inline-block;max-width:100%;padding:12px 20px;border-radius:0.25rem;background-color: #a855f7;text-align:center;font-size:12px;font-weight:600;color:rgb(255,255,255);text-decoration-line:none"><span></span><span style="p-x:20px;p-y:12px;max-width:100%;display:inline-block;line-height:120%;text-decoration:none;text-transform:none;mso-padding-alt:0px;mso-text-raise:9px"</span><span>Reactivate</span></a></td>
                                  </tr>
                                </tbody>
                          </table>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">Best,<p target="_blank" style="color:rgb(0,0,0);text-decoration:none;text-decoration-line:none">The <strong>${process.env.COMPANY}</strong> Team</p></p>
                          </td>
                      </tr>
                    </table>
                  </body>
                
                </html>`,
    };

    await transporter.sendMail(mailOptions);
    res.json({ success: true, message: "" });
  } catch (error) {
    console.log("Error", error);
  }
});

//PAYSTACK PAYMENT
app.post("/api/paystackpayment", async (req, res) => {
  const { planId, amountInZar, email } = req.body;
  try {
    const data = {
      email: email,
      amount: amountInZar,
      plan: planId,
    };

    axios
      .post("https://api.paystack.co/transaction/initialize", data, {
        headers: {
          Authorization: `Bearer ${process.env.PAYSTACK_SECRET_KEY}`,
          "Content-Type": "application/json",
        },
      })
      .then((response) => {
        if (response.data.status) {
          const authorizationUrl = response.data.data.authorization_url;
          res.json({ url: authorizationUrl });
        } else {
          res.status(500).json({ error: "Internal Server Error" });
        }
      })
      .catch((error) => {
        res.status(500).json({ error: "Internal Server Error" });
      });
  } catch (e) {
    console.log("Error", e);
    res.status(500).json({ error: e.message });
  }
});

//PAYSTACK GET DETAIL
app.post("/api/paystackfetch", async (req, res) => {
  const { email, uid, plan } = req.body;
  try {
    const searchEmail = email;
    const url = "https://api.paystack.co/subscription";
    const authorization = `Bearer ${process.env.PAYSTACK_SECRET_KEY}`;

    axios
      .get(url, {
        headers: {
          Authorization: authorization,
        },
      })
      .then(async (response) => {
        const jsonData = response.data;
        let subscriptionDetails = null;
        jsonData.data.forEach((subscription) => {
          if (subscription.customer.email === searchEmail) {
            subscriptionDetails = {
              subscription_code: subscription.subscription_code,
              createdAt: subscription.createdAt,
              updatedAt: subscription.updatedAt,
              customer_code: subscription.customer.customer_code,
            };
          }
        });

        if (subscriptionDetails) {
          let cost = 0;
          if (plan === process.env.MONTH_TYPE) {
            cost = process.env.MONTH_COST;
          } else {
            cost = process.env.YEAR_COST;
          }
          cost = cost / 4;

          await Admin.findOneAndUpdate(
            { type: "main" },
            { $inc: { total: cost } }
          );

          await User.findOneAndUpdate({ _id: uid }, { $set: { type: plan } })
            .then(async (result) => {
              res.json({ details: subscriptionDetails });
            })
            .catch((error) => {
              console.log("Error", error);
              res
                .status(500)
                .json({ success: false, message: "Internal server error" });
            });
        } else {
          res.status(500).json({ error: "Internal Server Error" });
        }
      })
      .catch((error) => {
        console.log("Error", error);
        res.status(500).json({ error: "Internal Server Error" });
      });
  } catch (e) {
    console.log("Error", e);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

//PAYSTACK PAYMENT
app.post("/api/paystackcancel", async (req, res) => {
  const { code, token, email } = req.body;

  const url = "https://api.paystack.co/subscription/disable";
  const authorization = `Bearer ${process.env.PAYSTACK_SECRET_KEY}`;
  const contentType = "application/json";
  const data = {
    code: code,
    token: token,
  };

  axios
    .post(url, data, {
      headers: {
        Authorization: authorization,
        "Content-Type": contentType,
      },
    })
    .then(async (response) => {
      const subscriptionDetails = await Subscription.findOne({
        subscriberId: email,
      });
      const userId = subscriptionDetails.user;

      await User.findOneAndUpdate({ _id: userId }, { $set: { type: "free" } });

      const userDetails = await User.findOne({ _id: userId });
      await Subscription.findOneAndDelete({ subscriberId: code });

      const transporter = nodemailer.createTransport({
        host: "smtp.gmail.com",
        port: 465,
        service: "gmail",
        secure: true,
        auth: {
          user: process.env.EMAIL,
          pass: process.env.PASSWORD,
        },
      });

      const Reactivate = process.env.WEBSITE_URL + "/pricing";

      const mailOptions = {
        from: process.env.EMAIL,
        to: email,
        subject: `${userDetails.mName} Your Subscription Plan Has Been Cancelled`,
        html: `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
                <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
                <html lang="en">
                
                  <head></head>
                 <div id="__react-email-preview" style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Subscription Cancelled<div> â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿</div>
                 </div>
                
                  <body style="padding:20px; margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;background-color:#f6f9fc;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;">
                    <table align="center" role="presentation" cellSpacing="0" cellPadding="0" border="0" height="80%" width="100%" style="max-width:37.5em;max-height:80%; margin-left:auto;margin-right:auto;margin-top:80px;margin-bottom:80px;width:465px;border-radius:0.25rem;border-width:1px;background-color:#fff;padding:20px">
                      <tr style="width:100%">
                        <td>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-top:32px">
                            <tbody>
                              <tr>
                                <td><img alt="Vercel" src="${process.env.LOGO}" width="40" height="37" style="display:block;outline:none;border:none;text-decoration:none;margin-left:auto;margin-right:auto;margin-top:0px;margin-bottom:0px" /></td>
                              </tr>
                            </tbody>
                          </table>
                          <h1 style="margin-left:0px;margin-right:0px;margin-top:30px;margin-bottom:30px;padding:0px;text-align:center;font-size:24px;font-weight:400;color:rgb(0,0,0)">Subscription Cancelled</h1>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">${userDetails.mName}, your subscription plan has been Cancelled. Reactivate your plan by clicking on the button below.</p>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-bottom:32px;margin-top:32px;text-align:center">
                               <tbody>
                                  <tr>
                                    <td><a href="${Reactivate}" target="_blank" style="p-x:20px;p-y:12px;line-height:100%;text-decoration:none;display:inline-block;max-width:100%;padding:12px 20px;border-radius:0.25rem;background-color: #a855f7;text-align:center;font-size:12px;font-weight:600;color:rgb(255,255,255);text-decoration-line:none"><span></span><span style="p-x:20px;p-y:12px;max-width:100%;display:inline-block;line-height:120%;text-decoration:none;text-transform:none;mso-padding-alt:0px;mso-text-raise:9px"</span><span>Reactivate</span></a></td>
                                  </tr>
                                </tbody>
                          </table>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">Best,<p target="_blank" style="color:rgb(0,0,0);text-decoration:none;text-decoration-line:none">The <strong>${process.env.COMPANY}</strong> Team</p></p>
                          </td>
                      </tr>
                    </table>
                  </body>
                </html>`,
      };

      await transporter.sendMail(mailOptions);
      res.json({ success: true, message: "" });
    });
});

//FLUTTERWAVE PAYMENT
app.post("/api/flutterwavecancel", async (req, res) => {
  const { code, token, email } = req.body;

  if (!flw) {
    res.status(500).json({ success: false, message: "Flutterwave not configured" });
    return;
  }

  if (!flw) {
    res.status(500).json({ success: false, message: "Flutterwave not configured" });
    return;
  }

  const payload = { id: code };
  const response = await flw.Subscription.cancel(payload);
  if (response) {
    const subscriptionDetails = await Subscription.findOne({
      subscriberId: email,
    });
    const userId = subscriptionDetails.user;

    await User.findOneAndUpdate({ _id: userId }, { $set: { type: "free" } });

    const userDetails = await User.findOne({ _id: userId });
    await Subscription.findOneAndDelete({ subscriberId: token });

    const transporter = nodemailer.createTransport({
      host: "smtp.gmail.com",
      port: 465,
      service: "gmail",
      secure: true,
      auth: {
        user: process.env.EMAIL,
        pass: process.env.PASSWORD,
      },
    });

    const Reactivate = process.env.WEBSITE_URL + "/pricing";

    const mailOptions = {
      from: process.env.EMAIL,
      to: email,
      subject: `${userDetails.mName} Your Subscription Plan Has Been Cancelled`,
      html: `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
                <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
                <html lang="en">
                
                  <head></head>
                 <div id="__react-email-preview" style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Subscription Cancelled<div> â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿ â€Œâ€‹â€â€â€ï»¿</div>
                 </div>
                
<body style="padding:20px; margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;background-color:#f6f9fc;font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;">
                    <table align="center" role="presentation" cellSpacing="0" cellPadding="0" border="0" height="80%" width="100%" style="max-width:37.5em;max-height:80%; margin-left:auto;margin-right:auto;margin-top:80px;margin-bottom:80px;width:465px;border-radius:0.25rem;border-width:1px;background-color:#fff;padding:20px">
                      <tr style="width:100%">
                        <td>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-top:32px">
                            <tbody>
                              <tr>
                                <td><img alt="Vercel" src="${process.env.LOGO}" width="40" height="37" style="display:block;outline:none;border:none;text-decoration:none;margin-left:auto;margin-right:auto;margin-top:0px;margin-bottom:0px" /></td>
                              </tr>
                            </tbody>
                          </table>
                          <h1 style="margin-left:0px;margin-right:0px;margin-top:30px;margin-bottom:30px;padding:0px;text-align:center;font-size:24px;font-weight:400;color:rgb(0,0,0)">Subscription Cancelled</h1>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">${userDetails.mName}, your subscription plan has been Cancelled. Reactivate your plan by clicking on the button below.</p>
                          <table align="center" border="0" cellPadding="0" cellSpacing="0" role="presentation" width="100%" style="margin-bottom:32px;margin-top:32px;text-align:center">
                               <tbody>
                                  <tr>
                                    <td><a href="${Reactivate}" target="_blank" style="p-x:20px;p-y:12px;line-height:100%;text-decoration:none;display:inline-block;max-width:100%;padding:12px 20px;border-radius:0.25rem;background-color: #a855f7;text-align:center;font-size:12px;font-weight:600;color:rgb(255,255,255);text-decoration-line:none"><span></span><span style="p-x:20px;p-y:12px;max-width:100%;display:inline-block;line-height:120%;text-decoration:none;text-transform:none;mso-padding-alt:0px;mso-text-raise:9px"</span><span>Reactivate</span></a></td>
                                  </tr>
                                </tbody>
                          </table>
                          <p style="font-size:14px;line-height:24px;margin:16px 0;color:rgb(0,0,0)">Best,<p target="_blank" style="color:rgb(0,0,0);text-decoration:none;text-decoration-line:none">The <strong>${process.env.COMPANY}</strong> Team</p></p>
                          </td>
                      </tr>
                    </table>
                  </body>
                
                </html>`,
    };

    await transporter.sendMail(mailOptions);
    res.json({ success: true, message: "" });
  } else {
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

//FLUTTERWAVE GET DETAILS
app.post("/api/flutterdetails", async (req, res) => {
  const { email, uid, plan } = req.body;
  try {
    let cost = 0;
    if (plan === process.env.MONTH_TYPE) {
      cost = process.env.MONTH_COST;
    } else {
      cost = process.env.YEAR_COST;
    }
    cost = cost / 4;

    await Admin.findOneAndUpdate({ type: "main" }, { $inc: { total: cost } });

    await User.findOneAndUpdate({ _id: uid }, { $set: { type: plan } })
      .then(async (result) => {
        const payload = { email: email };
        if (!flw) {
          res.status(500).json({ success: false, message: "Flutterwave not configured" });
          return;
        }
        if (!flw) {
          res.status(500).json({ success: false, message: "Flutterwave not configured" });
          return;
        }
        const response = await flw.Subscription.get(payload);

        res.send(response["data"][0]);
      })
      .catch((error) => {
        console.log("Error", error);
        res
          .status(500)
          .json({ success: false, message: "Internal server error" });
      });
  } catch (error) {
    console.log("Error", error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

//GET NOTES
app.post("/api/getnotes", async (req, res) => {
  const { course } = req.body;
  try {
    const existingNotes = await Notes.findOne({ course: course });
    if (existingNotes) {
      res.json({ success: true, message: existingNotes.notes });
    } else {
      res.json({ success: false, message: "" });
    }
  } catch (error) {
    console.log(error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

//SAVE NOTES
app.post("/api/savenotes", async (req, res) => {
  const { course, notes } = req.body;
  try {
    const existingNotes = await Notes.findOne({ course: course });

    if (existingNotes) {
      await Notes.findOneAndUpdate(
        { course: course },
        { $set: { notes: notes } }
      );
      res.json({ success: true, message: "Notes updated successfully" });
    } else {
      const newNotes = new Notes({ course: course, notes: notes });
      await newNotes.save();
      res.json({ success: true, message: "Notes created successfully" });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

//GENERATE EXAMS
app.post("/api/aiexam", requireAuth, async (req, res) => {
  const { courseId, mainTopic, subtopicsString, lang } = req.body;

  const existingNotes = await Exam.findOne({ course: courseId });
  if (existingNotes) {
    res.json({ success: true, message: existingNotes.exam });
  } else {
    const prompt = `Strictly in ${lang},
        generate a strictly 10 question MCQ quiz on title ${mainTopic} based on each topics :- ${subtopicsString}, Atleast One question per topic. Add options A, B, C, D and only one correct answer. Give your repones Strictly inJSON format like this :-
        {
          "${mainTopic}": [
            {
              "topic": "topic title",
              "question": "",
              "options": [
               "",
               "",
               "",
               ""
              ],
              "answer": "correct option like A, B, C, D"
            },
            {
              "topic": "topic title",
              "question": "",
              "options": [
               "",
               "",
               "",
               ""
              ],
              "answer": "correct option like A, B, C, D"
            },
            {
              "topic": "topic title",
              "question": "",
              "options": [
               "",
               "",
               "",
               ""
              ],
              "answer": "correct option like A, B, C, D"
            }
          ]
        }
        `;

    const safetySettings = [
      {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
      },
      {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
      },
      {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
      },
      {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
      },
    ];

    const genAI = await getAI();
    const model = genAI.getGenerativeModel({
      model: "gemini-2.0-flash",
      safetySettings,
    });

    await model
      .generateContent(prompt)
      .then(async (result) => {
        const response = result.response;
        const txt = response.text();
        let output = txt.slice(7, txt.length - 4);

        const newNotes = new Exam({
          course: courseId,
          exam: output,
          marks: "0",
          passed: false,
        });
        await newNotes.save();
        res.json({ success: true, message: output });
      })
      .catch((error) => {
        console.log(error);
        res.json({ success: false });
      });
  }
});

//UPDATE RESULT
app.post("/api/updateresult", async (req, res) => {
  const { courseId, marksString } = req.body;
  try {
    await Exam.findOneAndUpdate({ course: courseId }, [
      { $set: { marks: marksString, passed: true } },
    ])
      .then((result) => {
        res.json({ success: true });
      })
      .catch((error) => {
        res.json({ success: false });
      });
  } catch (error) {
    console.log("Error", error);
    res.status(500).send("Internal Server Error");
  }
});

//SEND EXAM
app.post("/api/sendexammail", async (req, res) => {
  const { html, email, subjects } = req.body;

  const transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 465,
    service: "gmail",
    secure: true,
    auth: {
      user: process.env.EMAIL,
      pass: process.env.PASSWORD,
    },
  });

  const options = {
    from: process.env.EMAIL,
    to: email,
    subject: "" + subjects,
    html: html,
  };

  transporter.sendMail(options, (error, info) => {
    if (error) {
      console.log("Error", error);
      res.status(500).json({ success: false, message: "Failed to send email" });
    } else {
      res.json({ success: true, message: "Email sent successfully" });
    }
  });
});

//GET COURSE PROGRESS (Renamed from getmyresult)
app.get("/api/course/:courseId/progress", requireAuth, async (req, res) => {
  const { courseId } = req.params;
  const userId = req.user._id.toString();
  
  try {
    // Check if user owns the course or has access
    const course = await Course.findById(courseId);
    if (!course) {
      return res.status(404).json({
        success: false,
        message: "Course not found"
      });
    }
    
    // Check access permissions
    const isOwner = course.user === userId;
    const isPublic = course.isPublic === true;
    
    if (!isPublic && !isOwner) {
      return res.status(403).json({
        success: false,
        message: "Access denied"
      });
    }
    
    // Get exam results and language info using correct model names
    const examResult = await Exam.findOne({ courseId: courseId, userId: userId });
    const languageInfo = await Language.findOne({ courseId: courseId, userId: userId });
    
    const response = {
      success: true,
      courseId: courseId,
      progress: {
        hasExamResult: !!examResult,
        examPassed: examResult ? examResult.passed : false,
        examScore: examResult ? examResult.score : null,
        completedAt: examResult ? examResult.completedAt : null
      },
      language: languageInfo ? languageInfo.lang : "English",
      course: {
        title: course.title || course.mainTopic,
        slug: course.slug,
        isPublic: course.isPublic
      }
    };
    
    res.json(response);
  } catch (error) {
    logger.error("Get course progress error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error"
    });
  }
});

//BACKWARD COMPATIBILITY: Legacy getmyresult endpoint (DEPRECATED)
app.post("/api/getmyresult", async (req, res) => {
  const { courseId } = req.body;
  
  // Add deprecation warning to response headers
  res.set('X-API-Deprecated', 'true');
  res.set('X-API-Deprecated-Message', 'Use GET /api/course/:courseId/progress instead');
  
  try {
    // Use correct model names (Exam and Language instead of ExamSchema and LangSchema)
    const existingExam = await Exam.findOne({ courseId: courseId });
    const lang = await Language.findOne({ courseId: courseId });
    
    if (existingExam) {
      res.json({
        success: true,
        message: existingExam.passed,
        lang: lang ? lang.lang : "English",
        // Add migration hint
        _deprecated: "This endpoint is deprecated. Use GET /api/course/:courseId/progress instead"
      });
    } else {
      res.json({ 
        success: false, 
        message: false, 
        lang: lang ? lang.lang : "English",
        _deprecated: "This endpoint is deprecated. Use GET /api/course/:courseId/progress instead"
      });
    }
  } catch (error) {
    logger.error("Legacy getmyresult error:", error);
    res.status(500).json({
      success: false,
      message: "Internal Server Error",
      _deprecated: "This endpoint is deprecated. Use GET /api/course/:courseId/progress instead"
    });
  }
});

//DELETE
app.post("/api/deleteuser", async (req, res) => {
  try {
    const { userId } = req.body;
    const deletedUser = await User.findOneAndDelete({ _id: userId });

    if (!deletedUser) {
      return res.json({ success: false, message: "Internal Server Error" });
    }

    await Course.deleteMany({ user: userId });
    await Subscription.deleteMany({ user: userId });

    return res.json({ success: true, message: "Profile deleted successfully" });
  } catch (error) {
    console.log("Error", error);
    return res.json({ success: false, message: "Internal Server Error" });
  }
});

// Blog management routes are now in routes/adminRoutes.js

//GET ALL BLOGS (Public - no pagination)
app.get("/api/blogs/public", async (req, res) => {
  try {
    const blogs = await Blog.find({}).sort({ date: -1 });

    res.json(blogs);
  } catch (error) {
    console.log(error);
    res.status(500).json({ success: false, message: "Internal Server Error" });
  }
});

// NEW API ROUTES (Section-based architecture)
// Mount the new API routes with enhanced course management
app.use('/api', apiRoutes);

//STATIC FILE SERVING
// Serve static files from the dist directory (in parent directory)
app.use(express.static("../dist"));

// Catch-all handler: send back index.html for client-side routing
// Only for non-API routes
app.get("*", (req, res, next) => {
  // Skip API routes
  if (req.path.startsWith("/api/")) {
    return next();
  }

  // Send index.html for client-side routing
  res.sendFile("index.html", { root: "../dist" }, (err) => {
    if (err) {
      logger.error(`Error serving index.html: ${err.message}`);
      // If dist doesn't exist (development), just send a simple response
      res
        .status(404)
        .send("Frontend not built. Run npm run build in the root directory.");
    }
  });
});

//LISTEN
// Error handling middleware (must be last)
app.use(errorHandler);

// Dynamic port handling
const startServer = async () => {
  try {
    const serverPort = await getServerPort(PORT);
    const serverURL = getServerURL(serverPort);

    const server = app.listen(serverPort, async () => {
      logger.info(`ğŸš€ Server started successfully!`);
      logger.info(`ğŸ“ Environment: ${process.env.NODE_ENV || "development"}`);
      logger.info(`ğŸŒ Server URL: ${serverURL}`);
      logger.info(`â¤ï¸  Health check: ${serverURL}/api/health`);
      logger.info(`ğŸ”— API Base URL: ${serverURL}/api`);

      // Initialize settings cache
      try {
        await settingsCache.preload();
        logger.info(`âš™ï¸  Settings cache initialized`);
      } catch (error) {
        logger.error(`âŒ Settings cache initialization failed:`, error);
      }

      // Initialize database optimizations
      try {
        await databaseOptimizationService.initialize();
        logger.info(`ğŸ”§ Database optimizations initialized`);
      } catch (error) {
        logger.error(`âŒ Database optimization initialization failed:`, error);
      }

      // Initialize scheduled cleanup job for stale files
      const CLEANUP_INTERVAL = 15 * 60 * 1000; // 15 minutes
      const FILE_MAX_AGE = 60 * 60 * 1000; // 1 hour

      const cleanupStaleFiles = async () => {
        try {
          logger.info("Running scheduled cleanup job for stale files");

          const tempDir = uploadConfig.tempDir;
          const now = Date.now();

          // Read all files in temp directory
          const files = await fs.readdir(tempDir);

          let deletedCount = 0;
          let errorCount = 0;

          for (const file of files) {
            try {
              const filePath = path.join(tempDir, file);
              const stats = await fs.stat(filePath);

              // Check if file is older than 1 hour
              const fileAge = now - stats.mtimeMs;

              if (fileAge > FILE_MAX_AGE) {
                const success = await cleanupFile(filePath);
                if (success) {
                  deletedCount++;
                  logger.info(
                    `Deleted stale file: ${file} (age: ${Math.round(
                      fileAge / 1000 / 60
                    )} minutes)`
                  );
                } else {
                  errorCount++;
                }
              }
            } catch (error) {
              logger.error(
                `Error processing file ${file} during cleanup: ${error.message}`
              );
              errorCount++;
            }
          }

          if (deletedCount > 0 || errorCount > 0) {
            logger.info(
              `Cleanup job completed: ${deletedCount} files deleted, ${errorCount} errors`
            );
          }
        } catch (error) {
          logger.error(`Scheduled cleanup job failed: ${error.message}`);
        }
      };

      // Run cleanup immediately on startup
      cleanupStaleFiles();

      // Schedule cleanup to run every 15 minutes
      setInterval(cleanupStaleFiles, CLEANUP_INTERVAL);
      logger.info(
        `ğŸ§¹ Scheduled cleanup job initialized (runs every ${
          CLEANUP_INTERVAL / 1000 / 60
        } minutes)`
      );

      // Update environment variables for other parts of the app
      process.env.ACTUAL_PORT = serverPort.toString();
      process.env.ACTUAL_SERVER_URL = serverURL;

      // Log port change if different from preferred
      if (serverPort !== PORT) {
        logger.warn(
          `âš ï¸  Using port ${serverPort} instead of preferred port ${PORT}`
        );
        logger.info(`ğŸ’¡ Update your frontend VITE_SERVER_URL to: ${serverURL}`);
      }
    });

    return server;
  } catch (error) {
    logger.error(`âŒ Failed to start server: ${error.message}`);
    process.exit(1);
  }
};

const server = await startServer();

//QUIZ ENDPOINTS

//CREATE QUIZ
app.post("/api/quiz/create", requireAuth, async (req, res) => {
  // Generate request ID for logging correlation
  const requestId = logger.llm.generateRequestId();
  const startTime = Date.now();

  try {
    const {
      userId,
      keyword,
      title,
      format,
      provider,
      model,
      questionAndAnswers,
      isPublic,
    } = req.body;

    // Log request start
    logger.llm.logRequestStart(
      requestId,
      "/api/quiz/create",
      {
        keyword,
        title,
        format,
        provider,
        model,
      },
      userId,
      provider
    );

    if (!userId || !keyword || !title) {
      return res.status(400).json({
        success: false,
        message: "userId, keyword, and title are required",
      });
    }

    // Generate quiz content using AI
    const quizPrompt = `Create a comprehensive quiz about "${keyword}" with the title "${title}". 
        Format: ${format || "mixed"}
        
        Generate 15-20 multiple choice questions in this markdown format:
        # Question text here?
        - Wrong answer option
        -* Correct answer option (marked with *)
        - Wrong answer option
        - Wrong answer option
        ## Explanation of the correct answer here
        
        Make the questions challenging and cover various aspects of the topic.`;

    // Use LLM factory with provider selection
    const result = await llmService.generateContent(quizPrompt, {
      provider: provider,
      model: model,
    });

    if (!result.success) {
      logger.llm.logRequestError(
        requestId,
        "/api/quiz/create",
        new Error(result.error || "Failed to generate quiz content"),
        {
          userId,
          keyword,
          title,
          provider,
          model,
        }
      );
      throw new Error(result.error || "Failed to generate quiz content");
    }

    const quizContent = result.data.content;

    // Generate unique slug
    const baseSlug = generateSlug(`${title}-${Date.now()}`);
    const slug = await generateUniqueSlug(baseSlug, Quiz);

    // Create quiz
    const newQuiz = new Quiz({
      userId,
      keyword,
      title,
      slug,
      format: format || "mixed",
      content: quizContent,
      tokens: {
        prompt: quizPrompt.length,
        completion: quizContent.length,
        total: quizPrompt.length + quizContent.length,
      },
      questionAndAnswers: questionAndAnswers || [],
      viewCount: 0,
      lastVisitedAt: new Date(),
      createdAt: new Date(),
      updatedAt: new Date(),
      isPublic: isPublic ?? false, // Default to false for backward compatibility
    });

    await newQuiz.save();

    const duration = Date.now() - startTime;

    // Log successful quiz creation
    logger.llm.logRequestSuccess(
      requestId,
      "/api/quiz/create",
      {
        quizId: newQuiz._id,
        slug,
        keyword,
        title,
        contentLength: quizContent?.length,
        provider: result.data.provider,
      },
      duration,
      userId,
      result.data.provider
    );

    res.json({
      success: true,
      message: "Quiz created successfully",
      quiz: {
        _id: newQuiz._id,
        slug: newQuiz.slug,
        title: newQuiz.title,
        keyword: newQuiz.keyword,
        isPublic: newQuiz.isPublic,
      },
    });
  } catch (error) {
    // Log quiz creation error with context
    logger.llm.logRequestError(requestId, "/api/quiz/create", error, {
      userId: req.body.userId,
      keyword: req.body.keyword,
      title: req.body.title,
      provider: req.body.provider,
      model: req.body.model,
      duration: Date.now() - startTime,
    });

    res.status(500).json({
      success: false,
      message: "Failed to create quiz",
    });
  }
});

//GET USER QUIZZES
app.get("/api/quizzes", async (req, res) => {
  try {
    const { userId, page = 1, limit = 10, visibility = "all" } = req.query;

    if (!userId) {
      return res.status(400).json({
        success: false,
        message: "userId is required",
      });
    }

    // Build query based on visibility filter
    const query = { userId };
    if (visibility === "public") {
      query.isPublic = true;
    } else if (visibility === "private") {
      query.isPublic = false;
    }
    // 'all' means no additional filter

    const skip = (page - 1) * limit;
    const totalCount = await Quiz.countDocuments(query);
    const totalPages = Math.ceil(totalCount / limit);

    const quizzes = await Quiz.find(query)
      .select(
        "_id userId keyword title slug format tokens viewCount lastVisitedAt createdAt updatedAt isPublic forkCount forkedFrom ownerName"
      )
      .sort({ updatedAt: -1 })
      .skip(parseInt(skip))
      .limit(parseInt(limit));

    res.json({
      success: true,
      data: quizzes,
      totalCount,
      totalPages,
      currPage: parseInt(page),
      perPage: parseInt(limit),
    });
  } catch (error) {
    logger.error(`Get quizzes error: ${error.message}`, { error: error.stack });
    res.status(500).json({
      success: false,
      message: "Failed to fetch quizzes",
    });
  }
});

//GET QUIZ BY SLUG
app.get("/api/quiz/:slug", optionalAuth, async (req, res) => {
  try {
    const { slug } = req.params;

    const quiz = await Quiz.findOne({ slug });

    if (!quiz) {
      return res.status(404).json({
        success: false,
        message: "Quiz not found",
      });
    }

    // Check access control: content must be public OR user must be the owner
    const isOwner = req.user && quiz.userId === req.user._id.toString();
    const isPublic = quiz.isPublic === true;

    if (!isPublic && !isOwner) {
      return res.status(403).json({
        success: false,
        message: "This content is private",
      });
    }

    // Increment view count
    quiz.viewCount += 1;
    quiz.lastVisitedAt = new Date();
    await quiz.save();

    logger.info(`Quiz accessed by slug: ${slug}`);

    res.json({
      success: true,
      quiz: quiz,
    });
  } catch (error) {
    logger.error(`Get quiz by slug error: ${error.message}`, {
      error: error.stack,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Failed to fetch quiz",
    });
  }
});

//GET QUIZ BY ID (Legacy support)
app.get("/api/quiz/id/:id", async (req, res) => {
  try {
    const { id } = req.params;

    const quiz = await Quiz.findById(id);

    if (!quiz) {
      return res.status(404).json({
        success: false,
        message: "Quiz not found",
      });
    }

    // Increment view count
    quiz.viewCount += 1;
    quiz.lastVisitedAt = new Date();
    await quiz.save();

    // If quiz has slug, suggest redirect
    if (quiz.slug) {
      return res.json({
        success: true,
        quiz: quiz,
        redirect: `/quiz/${quiz.slug}`,
      });
    }

    logger.info(`Quiz accessed by ID: ${id}`);

    res.json({
      success: true,
      quiz: quiz,
    });
  } catch (error) {
    logger.error(`Get quiz by ID error: ${error.message}`, {
      error: error.stack,
      id: req.params.id,
    });
    res.status(500).json({
      success: false,
      message: "Failed to fetch quiz",
    });
  }
});

//DELETE QUIZ
app.delete("/api/quiz/:slug", async (req, res) => {
  try {
    const { slug } = req.params;
    const { userId } = req.body;

    if (!userId) {
      return res.status(400).json({
        success: false,
        message: "userId is required",
      });
    }

    const quiz = await Quiz.findOneAndDelete({ slug, userId });

    if (!quiz) {
      return res.status(404).json({
        success: false,
        message: "Quiz not found or unauthorized",
      });
    }

    logger.info(`Quiz deleted: ${quiz._id} (${slug})`);

    res.json({
      success: true,
      message: "Quiz deleted successfully",
    });
  } catch (error) {
    logger.error(`Delete quiz error: ${error.message}`, {
      error: error.stack,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Failed to delete quiz",
    });
  }
});

//CREATE FLASHCARD
app.post("/api/flashcard/create", requireAuth, async (req, res) => {
  // Generate request ID for logging correlation
  const requestId = logger.llm.generateRequestId();
  const startTime = Date.now();

  try {
    const { userId, keyword, title, provider, model, isPublic } = req.body;

    // Log request start
    logger.llm.logRequestStart(
      requestId,
      "/api/flashcard/create",
      {
        keyword,
        title,
        provider,
        model,
      },
      userId,
      provider
    );

    if (!userId || !keyword || !title) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields: userId, keyword, title",
      });
    }

    // Generate flashcard content using AI
    const prompt = `Create a comprehensive set of flashcards for the topic: "${keyword}". 
        
        Generate 15-20 flashcards that cover the key concepts, definitions, and important facts about this topic.
        
        Format your response as a JSON array where each flashcard has:
        - "front": The question or term (keep it concise)
        - "back": The answer or definition (detailed but clear)
        - "difficulty": "easy", "medium", or "hard"
        - "tags": Array of relevant tags for categorization
        
        Make sure the flashcards are educational, accurate, and cover different aspects of the topic.
        
        Example format:
        [
          {
            "front": "What is photosynthesis?",
            "back": "The process by which plants use sunlight, water, and carbon dioxide to produce glucose and oxygen.",
            "difficulty": "medium",
            "tags": ["biology", "plants", "energy"]
          }
        ]
        
        Return only the JSON array, no additional text.`;

    // Use LLM factory with provider selection
    const result = await llmService.generateContent(prompt, {
      provider: provider,
      model: model,
    });

    if (!result.success) {
      logger.llm.logRequestError(
        requestId,
        "/api/flashcard/create",
        new Error(result.error || "Failed to generate flashcard content"),
        {
          userId,
          keyword,
          title,
          provider,
          model,
        }
      );
      throw new Error(result.error || "Failed to generate flashcard content");
    }

    const generatedText = result.data.content;

    // Parse the generated flashcards
    let cards = [];
    try {
      // Clean the response to extract JSON
      const jsonMatch = generatedText.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        cards = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("No valid JSON found in response");
      }
    } catch (parseError) {
      logger.llm.logRequestError(
        requestId,
        "/api/flashcard/create",
        parseError,
        {
          userId,
          keyword,
          title,
          provider,
          model,
          step: "json_parsing",
          generatedText: generatedText?.substring(0, 200),
        }
      );
      return res.status(500).json({
        success: false,
        message: "Failed to parse generated flashcards",
      });
    }

    // Generate unique slug
    const slug = await generateUniqueSlug(title, Flashcard);

    // Create flashcard set
    const newFlashcard = new Flashcard({
      userId,
      keyword,
      title,
      slug,
      content: generatedText,
      cards,
      tokens: {
        prompt: prompt.length,
        completion: generatedText.length,
        total: prompt.length + generatedText.length,
      },
      isPublic: isPublic ?? false, // Default to false for backward compatibility
    });

    await newFlashcard.save();

    const duration = Date.now() - startTime;

    // Log successful flashcard creation
    logger.llm.logRequestSuccess(
      requestId,
      "/api/flashcard/create",
      {
        flashcardId: newFlashcard._id,
        slug,
        keyword,
        title,
        cardsCount: cards.length,
        contentLength: generatedText?.length,
        provider: result.data.provider,
      },
      duration,
      userId,
      result.data.provider
    );

    res.json({
      success: true,
      message: "Flashcard set created successfully",
      flashcardId: newFlashcard._id,
      slug: slug,
      cards: cards,
      isPublic: newFlashcard.isPublic,
    });
  } catch (error) {
    // Log flashcard creation error with context
    logger.llm.logRequestError(requestId, "/api/flashcard/create", error, {
      userId: req.body.userId,
      keyword: req.body.keyword,
      title: req.body.title,
      provider: req.body.provider,
      model: req.body.model,
      duration: Date.now() - startTime,
    });

    res.status(500).json({
      success: false,
      message: "Failed to create flashcard set",
    });
  }
});

//GET USER FLASHCARDS
app.get("/api/flashcards", async (req, res) => {
  try {
    const { userId, page = 1, limit = 10, visibility = "all" } = req.query;

    if (!userId) {
      return res.status(400).json({
        success: false,
        message: "userId is required",
      });
    }

    // Build query based on visibility filter
    const query = { userId };
    if (visibility === "public") {
      query.isPublic = true;
    } else if (visibility === "private") {
      query.isPublic = false;
    }
    // 'all' means no additional filter

    const skip = (page - 1) * limit;
    const flashcards = await Flashcard.find(query)
      .select(
        "title keyword slug createdAt cards viewCount isPublic forkCount forkedFrom ownerName"
      )
      .sort({ createdAt: -1 })
      .skip(parseInt(skip))
      .limit(parseInt(limit));

    const total = await Flashcard.countDocuments(query);

    // Add card count to each flashcard
    const flashcardsWithCount = flashcards.map((flashcard) => ({
      ...flashcard.toObject(),
      cardCount: flashcard.cards.length,
    }));

    res.json({
      success: true,
      flashcards: flashcardsWithCount,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(total / limit),
        totalItems: total,
        hasNext: page * limit < total,
        hasPrev: page > 1,
      },
    });
  } catch (error) {
    logger.error(`Get flashcards error: ${error.message}`, {
      error: error.stack,
    });
    res.status(500).json({
      success: false,
      message: "Failed to fetch flashcards",
    });
  }
});

//GET FLASHCARD BY SLUG
app.get("/api/flashcard/:slug", optionalAuth, async (req, res) => {
  try {
    const { slug } = req.params;
    const flashcard = await Flashcard.findOne({ slug });

    if (!flashcard) {
      return res.status(404).json({
        success: false,
        message: "Flashcard set not found",
      });
    }

    // Check access control: content must be public OR user must be the owner
    const isOwner = req.user && flashcard.userId === req.user._id.toString();
    const isPublic = flashcard.isPublic === true;

    if (!isPublic && !isOwner) {
      return res.status(403).json({
        success: false,
        message: "This content is private",
      });
    }

    // Update view count and last visited
    flashcard.viewCount += 1;
    flashcard.lastVisitedAt = new Date();
    await flashcard.save();

    logger.info(`Flashcard accessed by slug: ${slug}`);
    res.json({
      success: true,
      flashcard: flashcard,
    });
  } catch (error) {
    logger.error(`Get flashcard by slug error: ${error.message}`, {
      error: error.stack,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Failed to fetch flashcard set",
    });
  }
});

//DELETE FLASHCARD
app.delete("/api/flashcard/:slug", async (req, res) => {
  try {
    const { slug } = req.params;
    const { userId } = req.body;

    if (!userId) {
      return res.status(400).json({
        success: false,
        message: "userId is required",
      });
    }

    const flashcard = await Flashcard.findOne({ slug, userId });

    if (!flashcard) {
      return res.status(404).json({
        success: false,
        message: "Flashcard set not found or unauthorized",
      });
    }

    await Flashcard.deleteOne({ _id: flashcard._id });

    logger.info(`Flashcard deleted: ${flashcard._id} (${slug})`);

    res.json({
      success: true,
      message: "Flashcard set deleted successfully",
    });
  } catch (error) {
    logger.error(`Delete flashcard error: ${error.message}`, {
      error: error.stack,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Failed to delete flashcard set",
    });
  }
});

//CREATE GUIDE
app.post("/api/guide/create", requireAuth, async (req, res) => {
  // Generate request ID for logging correlation
  const requestId = logger.llm.generateRequestId();
  const startTime = Date.now();

  try {
    const { userId, keyword, title, customization, provider, model, isPublic } =
      req.body;

    // Log request start
    logger.llm.logRequestStart(
      requestId,
      "/api/guide/create",
      {
        keyword,
        title,
        customization,
        provider,
        model,
      },
      userId,
      provider
    );

    if (!userId || !keyword || !title) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields: userId, keyword, title",
      });
    }

    // Generate guide content using AI
    const prompt = `Create a comprehensive study guide for the topic: "${keyword}".

        Title: ${title}
        
        ${customization ? `Additional requirements: ${customization}` : ""}
        
        Create a detailed study guide with the following structure:

        # ${title}

        [Write comprehensive content here with sections, examples, and explanations]

        ## Related Topics
        - Topic 1
        - Topic 2  
        - Topic 3
        - Topic 4

        ## Deep Dive Topics
        - Advanced Topic 1
        - Advanced Topic 2
        - Advanced Topic 3

        ## Study Questions
        1. Question 1?
        2. Question 2?
        3. Question 3?
        4. Question 4?
        5. Question 5?

        Guidelines:
        - Content should be comprehensive but concise (single-page format)
        - Use markdown formatting with headers, lists, code blocks, and emphasis
        - Include practical examples and real-world applications
        - Make it suitable for quick reference and study
        - Related topics should be closely connected concepts (3-5 topics)
        - Deep dive topics should be advanced/specialized areas for further study (3-4 topics)
        - Questions should test understanding of key concepts (5-8 questions)
        - Aim for 2000-4000 words in the main content section
        
        Write the complete guide following this exact structure.`;

    // Use LLM factory with provider selection
    const result = await llmService.generateContent(prompt, {
      provider: provider,
      model: model,
    });

    if (!result.success) {
      logger.llm.logRequestError(
        requestId,
        "/api/guide/create",
        new Error(result.error || "Failed to generate guide content"),
        {
          userId,
          keyword,
          title,
          provider,
          model,
        }
      );
      throw new Error(result.error || "Failed to generate guide content");
    }

    const generatedText = result.data.content;

    // Log the raw response for debugging (first 500 chars)
    logger.info(`AI Response preview: ${generatedText.substring(0, 500)}...`);

    // Parse the generated guide from markdown structure
    let guideData = {};
    try {
      // Extract main content (everything before "## Related Topics")
      const relatedTopicsIndex = generatedText.indexOf("## Related Topics");
      let mainContent =
        relatedTopicsIndex > -1
          ? generatedText.substring(0, relatedTopicsIndex).trim()
          : generatedText;

      // Extract related topics
      let relatedTopics = [];
      const relatedMatch = generatedText.match(
        /## Related Topics\s*([\s\S]*?)(?=## |$)/
      );
      if (relatedMatch) {
        const relatedSection = relatedMatch[1];
        relatedTopics = relatedSection
          .split("\n")
          .filter((line) => line.trim().startsWith("-"))
          .map((line) => line.replace(/^-\s*/, "").trim())
          .filter((topic) => topic.length > 0);
      }

      // Extract deep dive topics
      let deepDiveTopics = [];
      const deepDiveMatch = generatedText.match(
        /## Deep Dive Topics\s*([\s\S]*?)(?=## |$)/
      );
      if (deepDiveMatch) {
        const deepDiveSection = deepDiveMatch[1];
        deepDiveTopics = deepDiveSection
          .split("\n")
          .filter((line) => line.trim().startsWith("-"))
          .map((line) => line.replace(/^-\s*/, "").trim())
          .filter((topic) => topic.length > 0);
      }

      // Extract study questions
      let questions = [];
      const questionsMatch = generatedText.match(
        /## Study Questions\s*([\s\S]*?)(?=## |$)/
      );
      if (questionsMatch) {
        const questionsSection = questionsMatch[1];
        questions = questionsSection
          .split("\n")
          .filter((line) => line.trim().match(/^\d+\./))
          .map((line) => line.replace(/^\d+\.\s*/, "").trim())
          .filter((question) => question.length > 0);
      }

      guideData = {
        content: mainContent,
        relatedTopics: relatedTopics,
        deepDiveTopics: deepDiveTopics,
        questions: questions,
      };

      logger.info(
        `Successfully parsed guide: ${relatedTopics.length} related topics, ${deepDiveTopics.length} deep dive topics, ${questions.length} questions`
      );
    } catch (parseError) {
      logger.error(`Guide parsing error: ${parseError.message}`);
      logger.error(`Stack trace: ${parseError.stack}`);
      logger.info("Using fallback parsing method");

      // Fallback: Use the raw content and try to extract some basic structure
      guideData = {
        content: generatedText,
        relatedTopics: [],
        deepDiveTopics: [],
        questions: [],
      };

      // Try to extract questions from anywhere in the content
      const questionMatches = generatedText.match(/\d+\.\s+([^?\n]*\?)/g);
      if (questionMatches) {
        guideData.questions = questionMatches
          .slice(0, 10)
          .map((q) => q.replace(/^\d+\.\s*/, ""));
      }
    }

    // Ensure we always have valid data
    if (!guideData || typeof guideData !== "object") {
      logger.warn("Guide data is invalid, creating minimal structure");
      guideData = {
        content:
          generatedText ||
          `# ${title}\n\nGuide content could not be parsed properly.`,
        relatedTopics: [],
        deepDiveTopics: [],
        questions: [],
      };
    }

    // Generate unique slug
    logger.info("Generating unique slug for guide");
    const slug = await generateUniqueSlug(title, Guide);
    logger.info(`Generated slug: ${slug}`);

    // Create guide
    logger.info("Creating new guide document");
    const newGuide = new Guide({
      userId,
      keyword,
      title,
      slug,
      content: guideData.content || generatedText,
      relatedTopics: guideData.relatedTopics || [],
      deepDiveTopics: guideData.deepDiveTopics || [],
      questions: guideData.questions || [],
      tokens: {
        prompt: prompt.length,
        completion: generatedText.length,
        total: prompt.length + generatedText.length,
      },
      isPublic: isPublic ?? false, // Default to false for backward compatibility
    });

    await newGuide.save();

    const duration = Date.now() - startTime;

    // Log successful guide creation
    logger.llm.logRequestSuccess(
      requestId,
      "/api/guide/create",
      {
        guideId: newGuide._id,
        slug,
        keyword,
        title,
        contentLength: generatedText?.length,
        relatedTopicsCount: guideData.relatedTopics?.length || 0,
        deepDiveTopicsCount: guideData.deepDiveTopics?.length || 0,
        questionsCount: guideData.questions?.length || 0,
        provider: result.data.provider,
      },
      duration,
      userId,
      result.data.provider
    );

    res.json({
      success: true,
      message: "Guide created successfully",
      guideId: newGuide._id,
      slug: slug,
      guide: {
        title: newGuide.title,
        keyword: newGuide.keyword,
        relatedTopics: newGuide.relatedTopics,
        deepDiveTopics: newGuide.deepDiveTopics,
        questions: newGuide.questions,
        isPublic: newGuide.isPublic,
      },
    });
  } catch (error) {
    // Log guide creation error with context
    logger.llm.logRequestError(requestId, "/api/guide/create", error, {
      userId: req.body.userId,
      keyword: req.body.keyword,
      title: req.body.title,
      provider: req.body.provider,
      model: req.body.model,
      duration: Date.now() - startTime,
    });

    res.status(500).json({
      success: false,
      message: `Failed to create guide: ${error.message}`,
    });
  }
});

//TEST ENDPOINT TO VERIFY CODE VERSION
app.get("/api/guide/test", (req, res) => {
  res.json({
    success: true,
    message: "Guide API updated - v2.0",
    timestamp: new Date().toISOString(),
  });
});

//GET USER GUIDES
app.get("/api/guides", async (req, res) => {
  try {
    const { userId, page = 1, limit = 10, visibility = "all" } = req.query;

    if (!userId) {
      return res.status(400).json({
        success: false,
        message: "userId is required",
      });
    }

    // Build query based on visibility filter
    const query = { userId };
    if (visibility === "public") {
      query.isPublic = true;
    } else if (visibility === "private") {
      query.isPublic = false;
    }
    // 'all' means no additional filter

    const skip = (page - 1) * limit;
    const guides = await Guide.find(query)
      .select(
        "title keyword slug createdAt viewCount relatedTopics isPublic forkCount forkedFrom ownerName"
      )
      .sort({ createdAt: -1 })
      .skip(parseInt(skip))
      .limit(parseInt(limit));

    const total = await Guide.countDocuments(query);

    res.json({
      success: true,
      guides: guides,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(total / limit),
        totalItems: total,
        hasNext: page * limit < total,
        hasPrev: page > 1,
      },
    });
  } catch (error) {
    logger.error(`Get guides error: ${error.message}`, { error: error.stack });
    res.status(500).json({
      success: false,
      message: "Failed to fetch guides",
    });
  }
});

//GET GUIDE BY SLUG
app.get("/api/guide/:slug", optionalAuth, async (req, res) => {
  try {
    const { slug } = req.params;
    const guide = await Guide.findOne({ slug });

    if (!guide) {
      return res.status(404).json({
        success: false,
        message: "Guide not found",
      });
    }

    // Check access control: content must be public OR user must be the owner
    const isOwner = req.user && guide.userId === req.user._id.toString();
    const isPublic = guide.isPublic === true;

    if (!isPublic && !isOwner) {
      return res.status(403).json({
        success: false,
        message: "This content is private",
      });
    }

    // Update view count and last visited
    guide.viewCount += 1;
    guide.lastVisitedAt = new Date();
    await guide.save();

    logger.info(`Guide accessed by slug: ${slug}`);
    res.json({
      success: true,
      guide: guide,
    });
  } catch (error) {
    logger.error(`Get guide by slug error: ${error.message}`, {
      error: error.stack,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Failed to fetch guide",
    });
  }
});

//DELETE GUIDE
app.delete("/api/guide/:slug", async (req, res) => {
  try {
    const { slug } = req.params;
    const { userId } = req.body;

    if (!userId) {
      return res.status(400).json({
        success: false,
        message: "userId is required",
      });
    }

    const guide = await Guide.findOne({ slug, userId });

    if (!guide) {
      return res.status(404).json({
        success: false,
        message: "Guide not found or unauthorized",
      });
    }

    await Guide.deleteOne({ _id: guide._id });

    logger.info(`Guide deleted: ${guide._id} (${slug})`);

    res.json({
      success: true,
      message: "Guide deleted successfully",
    });
  } catch (error) {
    logger.error(`Delete guide error: ${error.message}`, {
      error: error.stack,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Failed to delete guide",
    });
  }
});

//UPDATE GUIDE
app.patch("/api/guide/:slug", requireAuth, async (req, res) => {
  try {
    const { slug } = req.params;
    const userId = req.user._id.toString();
    const { content, title, keyword } = req.body;

    // Find the guide and verify ownership
    const guide = await Guide.findOne({ slug, userId });

    if (!guide) {
      return res.status(404).json({
        success: false,
        message: "Guide not found or unauthorized",
      });
    }

    // Update fields if provided
    if (content !== undefined) guide.content = content;
    if (title !== undefined) guide.title = title;
    if (keyword !== undefined) guide.keyword = keyword;

    await guide.save();

    logger.info(`Guide updated: ${guide._id} (${slug})`);

    res.json({
      success: true,
      message: "Guide updated successfully",
      guide,
    });
  } catch (error) {
    logger.error(`Update guide error: ${error.message}`, {
      error: error.stack,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Failed to update guide",
    });
  }
});

// DOCUMENT PROCESSING ENDPOINTS

// Upload and extract document
app.post(
  "/api/document/upload",
  requireAuth,
  uploadSingle,
  async (req, res) => {
    try {
      // Check if file was uploaded
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: "No file uploaded",
        });
      }

      const userId = req.user._id.toString();
      const file = req.file;

      logger.info(
        `Document upload started: ${file.originalname} by user ${userId}`
      );

      // Determine file type from mimetype
      let fileType;
      if (file.mimetype === "application/pdf") {
        fileType = "pdf";
      } else if (
        file.mimetype ===
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
      ) {
        fileType = "docx";
      } else if (file.mimetype === "text/plain") {
        fileType = "txt";
      } else {
        return res.status(400).json({
          success: false,
          message: "Unsupported file type",
        });
      }

      // Trigger document extraction with options object
      const result = await extractDocument({
        filePath: file.path,
        fileType: fileType,
        userId: userId,
        filename: file.originalname,
        fileSize: file.size,
      });

      res.json({
        success: true,
        processingId: result.processingId,
        status: result.status,
        message: "Document uploaded successfully and extraction started",
      });
    } catch (error) {
      logger.error(`Document upload error: ${error.message}`, {
        error: error.stack,
      });
      res.status(500).json({
        success: false,
        message: error.message || "Failed to upload document",
      });
    }
  }
);

// Extract text from URL
app.post("/api/document/extract-url", requireAuth, async (req, res) => {
  try {
    const { url } = req.body;
    const userId = req.user._id.toString();

    // Validate URL
    if (!url) {
      return res.status(400).json({
        success: false,
        message: "URL is required",
      });
    }

    // Validate URL format (HTTP/HTTPS only)
    const urlPattern = /^https?:\/\/.+/i;
    if (!urlPattern.test(url)) {
      return res.status(400).json({
        success: false,
        message: "Invalid URL format. Only HTTP and HTTPS URLs are supported",
      });
    }

    logger.info(`URL extraction started: ${url} by user ${userId}`);

    // Trigger URL extraction using extractDocument
    const result = await extractDocument({
      url: url,
      fileType: "url",
      userId: userId,
      filename: new URL(url).hostname,
    });

    res.json({
      success: true,
      processingId: result.processingId,
      status: result.status,
      message: "URL extraction started",
    });
  } catch (error) {
    logger.error(`URL extraction error: ${error.message}`, {
      error: error.stack,
    });
    res.status(500).json({
      success: false,
      message: error.message || "Failed to extract from URL",
    });
  }
});

// Get document processing status
app.get("/api/document/status/:id", requireAuth, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id.toString();

    // Find the processing record
    const processing = await DocumentProcessing.findById(id);

    if (!processing) {
      return res.status(404).json({
        success: false,
        message: "Processing record not found",
      });
    }

    // Verify user ownership
    if (processing.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized access to processing record",
      });
    }

    res.json({
      success: true,
      status: processing.extractionStatus,
      preview: processing.extractedTextPreview,
      textLength: processing.extractedTextLength,
      errorMessage: processing.errorMessage,
      filename: processing.filename,
      fileType: processing.fileType,
    });
  } catch (error) {
    logger.error(`Get status error: ${error.message}`, { error: error.stack });
    res.status(500).json({
      success: false,
      message: "Failed to get processing status",
    });
  }
});

// Get full extracted text
app.get("/api/document/text/:id", requireAuth, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id.toString();

    // Find the processing record
    const processing = await DocumentProcessing.findById(id);

    if (!processing) {
      return res.status(404).json({
        success: false,
        message: "Processing record not found",
      });
    }

    // Verify user ownership
    if (processing.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized access to processing record",
      });
    }

    // Check if extraction is complete
    if (processing.extractionStatus !== "completed") {
      return res.status(400).json({
        success: false,
        message: `Extraction not complete. Current status: ${processing.extractionStatus}`,
      });
    }

    res.json({
      success: true,
      text: processing.extractedText,
      filename: processing.filename,
      fileType: processing.fileType,
    });
  } catch (error) {
    logger.error(`Get text error: ${error.message}`, { error: error.stack });
    res.status(500).json({
      success: false,
      message: "Failed to get extracted text",
    });
  }
});

// CONTENT GENERATION FROM DOCUMENTS

// Generate course from document
app.post("/api/course/from-document", requireAuth, async (req, res) => {
  const { processingId, text, mainTopic, type, lang, isPublic } = req.body;
  const userId = req.user._id.toString();

  const requestId = logger.llm.generateRequestId();
  const startTime = Date.now();

  logger.llm.logRequestStart(
    requestId,
    "/api/course/from-document",
    {
      hasProcessingId: !!processingId,
      hasDirectText: !!text,
      mainTopic,
      type,
    },
    userId,
    "document-generation"
  );

  try {
    let extractedText = text;
    let sourceDocument = null;

    // If processing ID provided, retrieve extracted text
    if (processingId && !text) {
      const processing = await DocumentProcessing.findById(processingId);

      if (!processing) {
        return res.status(404).json({
          success: false,
          message: "Processing record not found",
        });
      }

      // Verify user ownership
      if (processing.userId !== userId) {
        return res.status(403).json({
          success: false,
          message: "Unauthorized access to processing record",
        });
      }

      // Check if extraction is complete
      if (processing.extractionStatus !== "completed") {
        return res.status(400).json({
          success: false,
          message: `Extraction not complete. Current status: ${processing.extractionStatus}`,
        });
      }

      extractedText = processing.extractedText;
      sourceDocument = {
        processingId: processing._id,
        filename: processing.filename,
        extractedFrom: processing.fileType,
      };
    }

    if (!extractedText) {
      return res.status(400).json({
        success: false,
        message: "Either processingId or text must be provided",
      });
    }

    // Generate course content using LLM
    const prompt = `Create a comprehensive educational course based on the following content. 
Structure it with clear sections, explanations, and examples.

Topic: ${mainTopic || "General"}
Type: ${type || "Course"}

Content:
${extractedText}

Please create a well-structured course with:
- Clear section headings
- Detailed explanations
- Practical examples where applicable
- Summary points

Format the response in markdown.`;

    const result = await llmService.generateContent(prompt, {
      temperature: 0.7,
    });

    if (!result.success) {
      logger.llm.logRequestError(
        requestId,
        "/api/course/from-document",
        new Error(result.error.message),
        {
          userId,
          mainTopic,
          hasSourceDocument: !!sourceDocument,
        }
      );

      return res.status(500).json({
        success: false,
        message: result.error.message || "Failed to generate course",
      });
    }

    const courseContent = result.data.content;

    // Get course photo from Unsplash
    let photo = null;
    try {
      const unsplashResult = await unsplash.search.getPhotos({
        query: mainTopic || "education",
        page: 1,
        perPage: 1,
        orientation: "landscape",
      });

      const firstPhoto = safeGetFirst(unsplashResult, "response.results");
      photo = safeGet(firstPhoto, "urls.regular", null);
    } catch (unsplashError) {
      logger.warn(
        `Unsplash API error for course from document: ${unsplashError.message}`
      );
    }

    // Generate slug
    const title = extractTitleFromContent(courseContent, mainTopic || "Course");
    const slug = await generateUniqueSlug(title, Course);

    // Create course
    const newCourse = new Course({
      user: userId,
      content: courseContent,
      type: type || "Course",
      mainTopic: mainTopic || "General",
      slug,
      photo,
      isPublic: isPublic ?? false,
      sourceDocument,
    });

    await newCourse.save();

    // Save language
    if (lang) {
      const newLang = new Language({ course: newCourse._id, lang });
      await newLang.save();
    }

    const duration = Date.now() - startTime;

    logger.llm.logRequestSuccess(
      requestId,
      "/api/course/from-document",
      {
        courseId: newCourse._id,
        slug,
        hasPhoto: !!photo,
        hasSourceDocument: !!sourceDocument,
        provider: result.data.provider,
      },
      duration,
      userId,
      result.data.provider
    );

    res.json({
      success: true,
      message: "Course created successfully from document",
      courseId: newCourse._id,
      slug,
      isPublic: newCourse.isPublic,
    });
  } catch (error) {
    logger.llm.logRequestError(requestId, "/api/course/from-document", error, {
      userId,
      mainTopic,
      hasProcessingId: !!processingId,
      hasText: !!text,
    });

    res.status(500).json({
      success: false,
      message: "Failed to create course from document",
    });
  }
});

// Generate quiz from document
app.post("/api/quiz/from-document", requireAuth, async (req, res) => {
  const { processingId, text, title, keyword } = req.body;
  const userId = req.user._id.toString();

  const requestId = logger.llm.generateRequestId();
  const startTime = Date.now();

  logger.llm.logRequestStart(
    requestId,
    "/api/quiz/from-document",
    {
      hasProcessingId: !!processingId,
      hasDirectText: !!text,
      title,
      keyword,
    },
    userId,
    "document-generation"
  );

  try {
    let extractedText = text;
    let sourceDocument = null;

    // If processing ID provided, retrieve extracted text
    if (processingId && !text) {
      const processing = await DocumentProcessing.findById(processingId);

      if (!processing) {
        return res.status(404).json({
          success: false,
          message: "Processing record not found",
        });
      }

      if (processing.userId !== userId) {
        return res.status(403).json({
          success: false,
          message: "Unauthorized access to processing record",
        });
      }

      if (processing.extractionStatus !== "completed") {
        return res.status(400).json({
          success: false,
          message: `Extraction not complete. Current status: ${processing.extractionStatus}`,
        });
      }

      extractedText = processing.extractedText;
      sourceDocument = {
        processingId: processing._id,
        filename: processing.filename,
        extractedFrom: processing.fileType,
      };
    }

    if (!extractedText) {
      return res.status(400).json({
        success: false,
        message: "Either processingId or text must be provided",
      });
    }

    // Check if content is sufficient for quiz generation
    if (extractedText.length < 100) {
      return res.status(422).json({
        success: false,
        message:
          "Insufficient content for quiz generation. Please provide more detailed content.",
      });
    }

    // Generate quiz using LLM
    const prompt = `Create a multiple-choice quiz based on the following content.

Title: ${title || "Quiz"}
Topic: ${keyword || "General"}

Content:
${extractedText}

Generate 5-10 multiple-choice questions with:
- Clear question text
- 4 answer options (A, B, C, D)
- One correct answer
- Brief explanation for the correct answer

Format as JSON array with structure:
[
  {
    "question": "Question text",
    "options": ["A) Option 1", "B) Option 2", "C) Option 3", "D) Option 4"],
    "correctAnswer": "A",
    "explanation": "Why this is correct"
  }
]`;

    const result = await llmService.generateContent(prompt, {
      temperature: 0.7,
    });

    if (!result.success) {
      logger.llm.logRequestError(
        requestId,
        "/api/quiz/from-document",
        new Error(result.error.message),
        {
          userId,
          title,
          hasSourceDocument: !!sourceDocument,
        }
      );

      return res.status(500).json({
        success: false,
        message: result.error.message || "Failed to generate quiz",
      });
    }

    // Parse quiz content
    let quizData;
    try {
      const content = result.data.content;
      // Try to extract JSON from markdown code blocks if present
      const jsonMatch =
        content.match(/```json\s*([\s\S]*?)\s*```/) ||
        content.match(/\[[\s\S]*\]/);
      const jsonString = jsonMatch ? jsonMatch[1] || jsonMatch[0] : content;
      quizData = JSON.parse(jsonString);
    } catch (parseError) {
      logger.error(`Failed to parse quiz JSON: ${parseError.message}`);
      return res.status(500).json({
        success: false,
        message: "Failed to parse generated quiz content",
      });
    }

    // Generate slug
    const slug = await generateUniqueSlug(title || "Quiz", Quiz);

    // Create quiz
    const newQuiz = new Quiz({
      userId,
      title: title || "Quiz",
      keyword: keyword || "General",
      slug,
      questions: quizData,
      sourceDocument,
    });

    await newQuiz.save();

    const duration = Date.now() - startTime;

    logger.llm.logRequestSuccess(
      requestId,
      "/api/quiz/from-document",
      {
        quizId: newQuiz._id,
        slug,
        questionCount: quizData.length,
        hasSourceDocument: !!sourceDocument,
        provider: result.data.provider,
      },
      duration,
      userId,
      result.data.provider
    );

    res.json({
      success: true,
      message: "Quiz created successfully from document",
      quizId: newQuiz._id,
      slug,
    });
  } catch (error) {
    logger.llm.logRequestError(requestId, "/api/quiz/from-document", error, {
      userId,
      title,
      hasProcessingId: !!processingId,
      hasText: !!text,
    });

    res.status(500).json({
      success: false,
      message: "Failed to create quiz from document",
    });
  }
});

// Generate flashcards from document
app.post("/api/flashcard/from-document", requireAuth, async (req, res) => {
  const { processingId, text, title, keyword } = req.body;
  const userId = req.user._id.toString();

  const requestId = logger.llm.generateRequestId();
  const startTime = Date.now();

  logger.llm.logRequestStart(
    requestId,
    "/api/flashcard/from-document",
    {
      hasProcessingId: !!processingId,
      hasDirectText: !!text,
      title,
      keyword,
    },
    userId,
    "document-generation"
  );

  try {
    let extractedText = text;
    let sourceDocument = null;

    // If processing ID provided, retrieve extracted text
    if (processingId && !text) {
      const processing = await DocumentProcessing.findById(processingId);

      if (!processing) {
        return res.status(404).json({
          success: false,
          message: "Processing record not found",
        });
      }

      if (processing.userId !== userId) {
        return res.status(403).json({
          success: false,
          message: "Unauthorized access to processing record",
        });
      }

      if (processing.extractionStatus !== "completed") {
        return res.status(400).json({
          success: false,
          message: `Extraction not complete. Current status: ${processing.extractionStatus}`,
        });
      }

      extractedText = processing.extractedText;
      sourceDocument = {
        processingId: processing._id,
        filename: processing.filename,
        extractedFrom: processing.fileType,
      };
    }

    if (!extractedText) {
      return res.status(400).json({
        success: false,
        message: "Either processingId or text must be provided",
      });
    }

    // Generate flashcards using LLM
    const prompt = `Create educational flashcards based on the following content.

Title: ${title || "Flashcards"}
Topic: ${keyword || "General"}

Content:
${extractedText}

Generate 10-15 flashcard pairs with:
- Front: A clear question or term
- Back: A concise answer or definition

Focus on key concepts, important terms, and essential information.

Format as JSON array with structure:
[
  {
    "front": "Question or term",
    "back": "Answer or definition"
  }
]`;

    const result = await llmService.generateContent(prompt, {
      temperature: 0.7,
    });

    if (!result.success) {
      logger.llm.logRequestError(
        requestId,
        "/api/flashcard/from-document",
        new Error(result.error.message),
        {
          userId,
          title,
          hasSourceDocument: !!sourceDocument,
        }
      );

      return res.status(500).json({
        success: false,
        message: result.error.message || "Failed to generate flashcards",
      });
    }

    // Parse flashcard content
    let flashcardData;
    try {
      const content = result.data.content;
      const jsonMatch =
        content.match(/```json\s*([\s\S]*?)\s*```/) ||
        content.match(/\[[\s\S]*\]/);
      const jsonString = jsonMatch ? jsonMatch[1] || jsonMatch[0] : content;
      flashcardData = JSON.parse(jsonString);
    } catch (parseError) {
      logger.error(`Failed to parse flashcard JSON: ${parseError.message}`);
      return res.status(500).json({
        success: false,
        message: "Failed to parse generated flashcard content",
      });
    }

    // Generate slug
    const slug = await generateUniqueSlug(title || "Flashcards", Flashcard);

    // Create flashcard set
    const newFlashcard = new Flashcard({
      userId,
      title: title || "Flashcards",
      keyword: keyword || "General",
      slug,
      cards: flashcardData,
      sourceDocument,
    });

    await newFlashcard.save();

    const duration = Date.now() - startTime;

    logger.llm.logRequestSuccess(
      requestId,
      "/api/flashcard/from-document",
      {
        flashcardId: newFlashcard._id,
        slug,
        cardCount: flashcardData.length,
        hasSourceDocument: !!sourceDocument,
        provider: result.data.provider,
      },
      duration,
      userId,
      result.data.provider
    );

    res.json({
      success: true,
      message: "Flashcards created successfully from document",
      flashcardId: newFlashcard._id,
      slug,
    });
  } catch (error) {
    logger.llm.logRequestError(
      requestId,
      "/api/flashcard/from-document",
      error,
      {
        userId,
        title,
        hasProcessingId: !!processingId,
        hasText: !!text,
      }
    );

    res.status(500).json({
      success: false,
      message: "Failed to create flashcards from document",
    });
  }
});

// Generate guide from document
app.post("/api/guide/from-document", requireAuth, async (req, res) => {
  const { processingId, text, title, keyword } = req.body;
  const userId = req.user._id.toString();

  const requestId = logger.llm.generateRequestId();
  const startTime = Date.now();

  logger.llm.logRequestStart(
    requestId,
    "/api/guide/from-document",
    {
      hasProcessingId: !!processingId,
      hasDirectText: !!text,
      title,
      keyword,
    },
    userId,
    "document-generation"
  );

  try {
    let extractedText = text;
    let sourceDocument = null;

    // If processing ID provided, retrieve extracted text
    if (processingId && !text) {
      const processing = await DocumentProcessing.findById(processingId);

      if (!processing) {
        return res.status(404).json({
          success: false,
          message: "Processing record not found",
        });
      }

      if (processing.userId !== userId) {
        return res.status(403).json({
          success: false,
          message: "Unauthorized access to processing record",
        });
      }

      if (processing.extractionStatus !== "completed") {
        return res.status(400).json({
          success: false,
          message: `Extraction not complete. Current status: ${processing.extractionStatus}`,
        });
      }

      extractedText = processing.extractedText;
      sourceDocument = {
        processingId: processing._id,
        filename: processing.filename,
        extractedFrom: processing.fileType,
      };
    }

    if (!extractedText) {
      return res.status(400).json({
        success: false,
        message: "Either processingId or text must be provided",
      });
    }

    // Generate guide using LLM
    const prompt = `Create a comprehensive study guide based on the following content.

Title: ${title || "Study Guide"}
Topic: ${keyword || "General"}

Content:
${extractedText}

Create a well-structured guide with:
- Overview/Introduction
- Key concepts and definitions
- Detailed explanations
- Important points to remember
- Summary

Format the response in markdown with clear headings and sections.`;

    const result = await llmService.generateContent(prompt, {
      temperature: 0.7,
    });

    if (!result.success) {
      logger.llm.logRequestError(
        requestId,
        "/api/guide/from-document",
        new Error(result.error.message),
        {
          userId,
          title,
          hasSourceDocument: !!sourceDocument,
        }
      );

      return res.status(500).json({
        success: false,
        message: result.error.message || "Failed to generate guide",
      });
    }

    const guideContent = result.data.content;

    // Generate slug
    const slug = await generateUniqueSlug(title || "Guide", Guide);

    // Create guide
    const newGuide = new Guide({
      userId,
      title: title || "Guide",
      keyword: keyword || "General",
      slug,
      content: guideContent,
      sourceDocument,
    });

    await newGuide.save();

    const duration = Date.now() - startTime;

    logger.llm.logRequestSuccess(
      requestId,
      "/api/guide/from-document",
      {
        guideId: newGuide._id,
        slug,
        hasSourceDocument: !!sourceDocument,
        provider: result.data.provider,
      },
      duration,
      userId,
      result.data.provider
    );

    res.json({
      success: true,
      message: "Guide created successfully from document",
      guideId: newGuide._id,
      slug,
    });
  } catch (error) {
    logger.llm.logRequestError(requestId, "/api/guide/from-document", error, {
      userId,
      title,
      hasProcessingId: !!processingId,
      hasText: !!text,
    });

    res.status(500).json({
      success: false,
      message: "Failed to create guide from document",
    });
  }
});

// VISIBILITY MANAGEMENT ENDPOINTS

// Helper function to get the correct model based on content type
const getContentModel = (contentType) => {
  const models = {
    course: Course,
    quiz: Quiz,
    flashcard: Flashcard,
    guide: Guide,
  };
  return models[contentType];
};

// PATCH endpoint for toggling content visibility
app.patch(
  "/api/:contentType/:slug/visibility",
  requireAuth,
  async (req, res) => {
    try {
      const { contentType, slug } = req.params;
      const { isPublic } = req.body;
      const userId = req.user._id.toString();

      // Validate content type
      const Model = getContentModel(contentType);
      if (!Model) {
        return res.status(400).json({
          success: false,
          message: "Invalid content type",
        });
      }

      // Validate isPublic parameter
      if (typeof isPublic !== "boolean") {
        return res.status(400).json({
          success: false,
          message: "isPublic must be a boolean value",
        });
      }

      // Find content by slug
      const content = await Model.findOne({ slug });

      if (!content) {
        return res.status(404).json({
          success: false,
          message: `${
            contentType.charAt(0).toUpperCase() + contentType.slice(1)
          } not found`,
        });
      }

      // Verify ownership
      if (content.userId !== userId && content.user !== userId) {
        return res.status(403).json({
          success: false,
          message: "You do not have permission to modify this content",
        });
      }

      // Update visibility
      content.isPublic = isPublic;
      await content.save();

      logger.info(
        `${contentType} visibility updated: ${slug} - isPublic: ${isPublic}`
      );

      res.json({
        success: true,
        isPublic: content.isPublic,
        message: `${
          contentType.charAt(0).toUpperCase() + contentType.slice(1)
        } visibility updated successfully`,
      });
    } catch (error) {
      logger.error(`Toggle visibility error: ${error.message}`, {
        error: error.stack,
        contentType: req.params.contentType,
        slug: req.params.slug,
      });
      res.status(500).json({
        success: false,
        message: "Failed to update visibility",
      });
    }
  }
);

// GET endpoint for visibility status
app.get("/api/:contentType/:slug/visibility", requireAuth, async (req, res) => {
  try {
    const { contentType, slug } = req.params;
    const userId = req.user._id.toString();

    // Validate content type
    const Model = getContentModel(contentType);
    if (!Model) {
      return res.status(400).json({
        success: false,
        message: "Invalid content type",
      });
    }

    // Find content by slug
    const content = await Model.findOne({ slug });

    if (!content) {
      return res.status(404).json({
        success: false,
        message: `${
          contentType.charAt(0).toUpperCase() + contentType.slice(1)
        } not found`,
      });
    }

    // Verify ownership
    if (content.userId !== userId && content.user !== userId) {
      return res.status(403).json({
        success: false,
        message:
          "You do not have permission to view this content visibility status",
      });
    }

    logger.info(`${contentType} visibility status retrieved: ${slug}`);

    res.json({
      success: true,
      isPublic: content.isPublic || false,
      forkCount: content.forkCount || 0,
    });
  } catch (error) {
    logger.error(`Get visibility status error: ${error.message}`, {
      error: error.stack,
      contentType: req.params.contentType,
      slug: req.params.slug,
    });
    res.status(500).json({
      success: false,
      message: "Failed to retrieve visibility status",
    });
  }
});

// PUBLIC CONTENT DISCOVERY ENDPOINTS

// GET unified public content endpoint
app.get("/api/public/content", optionalAuth, async (req, res) => {
  try {
    const {
      type = "all",
      page = 1,
      limit = 20,
      search = "",
      sortBy = "recent",
    } = req.query;

    // Validate and parse pagination parameters
    const pageNum = Math.max(1, parseInt(page));
    const limitNum = Math.min(100, Math.max(1, parseInt(limit))); // Max 100 items per page
    const skip = (pageNum - 1) * limitNum;

    // Build base query for public content
    const baseQuery = { isPublic: true };

    // Add search functionality if search term provided
    if (search && search.trim()) {
      const searchRegex = new RegExp(search.trim(), "i");
      baseQuery.$or = [
        { title: searchRegex },
        { keyword: searchRegex },
        { mainTopic: searchRegex },
      ];
    }

    // Determine which models to query based on type
    let modelsToQuery = [];
    if (type === "all") {
      modelsToQuery = [
        { model: Course, type: "course" },
        { model: Quiz, type: "quiz" },
        { model: Flashcard, type: "flashcard" },
        { model: Guide, type: "guide" },
      ];
    } else {
      const Model = getContentModel(type);
      if (!Model) {
        return res.status(400).json({
          success: false,
          message:
            "Invalid content type. Must be: course, quiz, flashcard, guide, or all",
        });
      }
      modelsToQuery = [{ model: Model, type }];
    }

    // Determine sort order
    let sortOptions = {};
    switch (sortBy) {
      case "popular":
        sortOptions = { viewCount: -1, createdAt: -1 };
        break;
      case "forks":
        sortOptions = { forkCount: -1, createdAt: -1 };
        break;
      case "recent":
      default:
        sortOptions = { createdAt: -1 };
        break;
    }

    // Query all relevant models
    const contentPromises = modelsToQuery.map(async ({ model, type }) => {
      const items = await model
        .find(baseQuery)
        .select(
          "title slug keyword mainTopic ownerName userId user forkCount viewCount createdAt date isPublic forkedFrom"
        )
        .sort(sortOptions)
        .lean();

      // Add contentType field to each item
      return items.map((item) => ({
        ...item,
        contentType: type,
        // Normalize date field (Course uses 'date', others use 'createdAt')
        createdAt: item.createdAt || item.date,
      }));
    });

    // Wait for all queries to complete
    const allContentArrays = await Promise.all(contentPromises);
    const allContent = allContentArrays.flat();

    // Sort combined results
    allContent.sort((a, b) => {
      if (sortBy === "popular") {
        return (b.viewCount || 0) - (a.viewCount || 0);
      } else if (sortBy === "forks") {
        return (b.forkCount || 0) - (a.forkCount || 0);
      } else {
        return new Date(b.createdAt) - new Date(a.createdAt);
      }
    });

    // Apply pagination to combined results
    const totalItems = allContent.length;
    const paginatedContent = allContent.slice(skip, skip + limitNum);
    const totalPages = Math.ceil(totalItems / limitNum);

    logger.info(
      `Public content retrieved: type=${type}, page=${pageNum}, results=${paginatedContent.length}`
    );

    res.json({
      success: true,
      data: paginatedContent,
      pagination: {
        currentPage: pageNum,
        totalPages,
        totalItems,
        itemsPerPage: limitNum,
        hasNext: pageNum < totalPages,
        hasPrev: pageNum > 1,
      },
    });
  } catch (error) {
    logger.error(`Get public content error: ${error.message}`, {
      error: error.stack,
      query: req.query,
    });
    res.status(500).json({
      success: false,
      message: "Failed to retrieve public content",
    });
  }
});

// GET public content by specific type
app.get("/api/public/:contentType", optionalAuth, async (req, res) => {
  try {
    const { contentType } = req.params;
    const { page = 1, limit = 20, search = "", sortBy = "recent" } = req.query;

    // Validate content type
    const Model = getContentModel(contentType);
    if (!Model) {
      return res.status(400).json({
        success: false,
        message:
          "Invalid content type. Must be: course, quiz, flashcard, or guide",
      });
    }

    // Validate and parse pagination parameters
    const pageNum = Math.max(1, parseInt(page));
    const limitNum = Math.min(100, Math.max(1, parseInt(limit)));
    const skip = (pageNum - 1) * limitNum;

    // Build query for public content
    const query = { isPublic: true };

    // Add search functionality
    if (search && search.trim()) {
      const searchRegex = new RegExp(search.trim(), "i");
      query.$or = [
        { title: searchRegex },
        { keyword: searchRegex },
        { mainTopic: searchRegex },
      ];
    }

    // Determine sort order
    let sortOptions = {};
    switch (sortBy) {
      case "popular":
        sortOptions = { viewCount: -1, createdAt: -1 };
        break;
      case "forks":
        sortOptions = { forkCount: -1, createdAt: -1 };
        break;
      case "recent":
      default:
        sortOptions = { createdAt: -1 };
        break;
    }

    // Get total count for pagination
    const totalItems = await Model.countDocuments(query);

    // Query content with pagination
    const content = await Model.find(query)
      .select(
        "title slug keyword mainTopic ownerName userId user forkCount viewCount createdAt date isPublic forkedFrom"
      )
      .sort(sortOptions)
      .skip(skip)
      .limit(limitNum)
      .lean();

    // Add contentType field and normalize date
    const normalizedContent = content.map((item) => ({
      ...item,
      contentType,
      createdAt: item.createdAt || item.date,
    }));

    const totalPages = Math.ceil(totalItems / limitNum);

    logger.info(
      `Public ${contentType} content retrieved: page=${pageNum}, results=${content.length}`
    );

    res.json({
      success: true,
      data: normalizedContent,
      pagination: {
        currentPage: pageNum,
        totalPages,
        totalItems,
        itemsPerPage: limitNum,
        hasNext: pageNum < totalPages,
        hasPrev: pageNum > 1,
      },
    });
  } catch (error) {
    logger.error(
      `Get public ${req.params.contentType} error: ${error.message}`,
      {
        error: error.stack,
        contentType: req.params.contentType,
        query: req.query,
      }
    );
    res.status(500).json({
      success: false,
      message: `Failed to retrieve public ${req.params.contentType} content`,
    });
  }
});

// GET single public content by slug
app.get("/api/public/:contentType/:slug", optionalAuth, async (req, res) => {
  try {
    const { contentType, slug } = req.params;

    // Validate content type
    const Model = getContentModel(contentType);
    if (!Model) {
      return res.status(400).json({
        success: false,
        message:
          "Invalid content type. Must be: course, quiz, flashcard, or guide",
      });
    }

    // Find content by slug
    const content = await Model.findOne({ slug }).lean();

    if (!content) {
      return res.status(404).json({
        success: false,
        message: `${
          contentType.charAt(0).toUpperCase() + contentType.slice(1)
        } not found`,
      });
    }

    // Check if content is public
    if (!content.isPublic) {
      return res.status(403).json({
        success: false,
        message: "This content is private and cannot be accessed",
      });
    }

    // Add contentType field
    const normalizedContent = {
      ...content,
      contentType,
      createdAt: content.createdAt || content.date,
    };

    logger.info(`Public ${contentType} retrieved: ${slug}`);

    res.json({
      success: true,
      content: normalizedContent,
    });
  } catch (error) {
    logger.error(
      `Get public ${req.params.contentType} by slug error: ${error.message}`,
      {
        error: error.stack,
        contentType: req.params.contentType,
        slug: req.params.slug,
      }
    );
    res.status(500).json({
      success: false,
      message: `Failed to retrieve public ${req.params.contentType}`,
    });
  }
});

// FORK FUNCTIONALITY ENDPOINTS

// POST endpoint for forking content
app.post("/api/:contentType/:slug/fork", requireAuth, async (req, res) => {
  try {
    const { contentType, slug } = req.params;
    const userId = req.user._id.toString();
    const userName = req.user.mName || req.user.email;

    // Validate content type
    const Model = getContentModel(contentType);
    if (!Model) {
      return res.status(400).json({
        success: false,
        message: "Invalid content type",
      });
    }

    // Find the original content by slug
    const originalContent = await Model.findOne({ slug });

    if (!originalContent) {
      return res.status(404).json({
        success: false,
        message: `${
          contentType.charAt(0).toUpperCase() + contentType.slice(1)
        } not found`,
      });
    }

    // Check if content is public
    if (!originalContent.isPublic) {
      return res.status(403).json({
        success: false,
        message: "Cannot fork private content",
      });
    }

    // Check if user is trying to fork their own content
    const originalOwnerId = originalContent.userId || originalContent.user;
    if (originalOwnerId === userId) {
      return res.status(400).json({
        success: false,
        message: "Cannot fork your own content",
      });
    }

    // Create a copy of the content
    const contentCopy = originalContent.toObject();
    delete contentCopy._id;
    delete contentCopy.__v;

    // Generate a unique slug for the forked content
    const baseSlug = `${slug}-fork`;
    const uniqueSlug = await generateUniqueSlug(Model, baseSlug);

    // Set forked content properties
    contentCopy.slug = uniqueSlug;
    contentCopy.userId = userId;
    contentCopy.user = userId; // For backward compatibility with Course model
    contentCopy.isPublic = false; // Forked content is private by default
    contentCopy.forkCount = 0; // Reset fork count for the copy
    contentCopy.viewCount = 0; // Reset view count
    contentCopy.ownerName = userName;

    // Set forkedFrom metadata
    contentCopy.forkedFrom = {
      contentId: originalContent._id,
      originalOwnerId: originalOwnerId,
      originalOwnerName: originalContent.ownerName || "Unknown User",
      forkedAt: new Date(),
    };

    // Create the forked content
    const forkedContent = new Model(contentCopy);
    await forkedContent.save();

    // Increment fork count on original content
    await Model.findByIdAndUpdate(originalContent._id, {
      $inc: { forkCount: 1 },
    });

    logger.info(
      `Content forked successfully: ${contentType}/${slug} -> ${uniqueSlug} by user ${userId}`
    );

    res.json({
      success: true,
      message: "Content forked successfully",
      forkedContent: {
        _id: forkedContent._id,
        slug: forkedContent.slug,
        contentType,
      },
    });
  } catch (error) {
    logger.error(`Fork ${req.params.contentType} error: ${error.message}`, {
      error: error.stack,
      contentType: req.params.contentType,
      slug: req.params.slug,
      userId: req.user?._id,
    });
    res.status(500).json({
      success: false,
      message: `Failed to fork ${req.params.contentType}`,
    });
  }
});

// Use API routes
app.use('/api', apiRoutes);

// Initialize optimization services and run migrations on startup
const initializeServer = async () => {
  try {
    logger.info('ğŸš€ Initializing server...');
    
    // Initialize database optimization services
    await databaseOptimizationService.initialize();
    // cachingService initializes itself when imported
    logger.info('âœ… Optimization services initialized');
    
    // Run related model migration
    logger.info('ğŸ”„ Running related model migration...');
    const migrationResults = await relatedModelMigrationService.migrateAllModels({
      dryRun: false,
      batchSize: 50
    });
    logger.info('âœ… Related model migration completed:', migrationResults);
    
    // Perform consistency checks
    const consistencyResults = await relatedModelMigrationService.performConsistencyChecks();
    if (consistencyResults.orphanedNotes > 0 || consistencyResults.orphanedExams > 0 || consistencyResults.orphanedLanguages > 0) {
      logger.warn('âš ï¸ Found orphaned data:', consistencyResults);
    } else {
      logger.info('âœ… Data consistency check passed');
    }
    
  } catch (error) {
    logger.error('âŒ Server initialization failed:', error);
    // Continue startup even if migration fails
  }
};

// Start server
const launchServer = async () => {
  try {
    const serverPort = await getServerPort();
    const httpServer = app.listen(serverPort, async () => {
      logger.info(`ğŸŒŸ Server running on port ${serverPort}`);
      logger.info(`ğŸŒ Server URL: ${getServerURL(serverPort)}`);
      
      // Initialize services and run migrations
      await initializeServer();
    });

    // Graceful shutdown
    const gracefulShutdown = (signal) => {
      logger.info(`Received ${signal}. Starting graceful shutdown...`);

      httpServer.close(() => {
        logger.info("HTTP server closed.");

        // Cleanup optimization services
        try {
          databaseOptimizationService.cleanup();
          cachingService.cleanup();
          logger.info("Optimization services cleaned up.");
        } catch (error) {
          logger.error("Error cleaning up optimization services:", error);
        }

        // Close database connection
        mongoose.connection.close(false, () => {
          logger.info("MongoDB connection closed.");
          process.exit(0);
        });
      });

      // Force close server after 30 seconds
      setTimeout(() => {
        logger.error(
          "Could not close connections in time, forcefully shutting down"
        );
        process.exit(1);
      }, 30000);
    };

    // Listen for termination signals
    process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
    process.on("SIGINT", () => gracefulShutdown("SIGINT"));
    
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
};

// Start the server
launchServer();
